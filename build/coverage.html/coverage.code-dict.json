{"/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/test.js":"/* istanbul instrument in package npmtest_react_native_fetch_blob */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/lib.npmtest_react_native_fetch_blob.js":"/* istanbul instrument in package npmtest_react_native_fetch_blob */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_react_native_fetch_blob = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_react_native_fetch_blob = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-react-native-fetch-blob && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_react_native_fetch_blob */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_react_native_fetch_blob\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_react_native_fetch_blob.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_react_native_fetch_blob.rollup.js'] =\n            local.assetsDict['/assets.npmtest_react_native_fetch_blob.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_react_native_fetch_blob.__dirname + '/lib.npmtest_react_native_fetch_blob.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/index.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  NativeAppEventEmitter,\n  Platform,\n  AsyncStorage,\n  AppState,\n} from 'react-native'\nimport type {\n  RNFetchBlobNative,\n  RNFetchBlobConfig,\n  RNFetchBlobStream,\n  RNFetchBlobResponseInfo\n} from './types'\nimport URIUtil from './utils/uri'\nimport StatefulPromise from './class/StatefulPromise.js'\nimport fs from './fs'\nimport getUUID from './utils/uuid'\nimport base64 from 'base-64'\nimport polyfill from './polyfill'\nimport _ from 'lodash'\nimport android from './android'\nimport ios from './ios'\nimport net from './net'\nimport JSONStream from './json-stream'\nconst {\n  RNFetchBlobSession,\n  readStream,\n  createFile,\n  unlink,\n  exists,\n  mkdir,\n  session,\n  writeStream,\n  readFile,\n  ls,\n  isDir,\n  mv,\n  cp\n} = fs\n\nconst Blob = polyfill.Blob\nconst emitter = DeviceEventEmitter\nconst RNFetchBlob = NativeModules.RNFetchBlob\n\n// when app resumes, check if there's any expired network task and trigger\n// their .expire event\nif(Platform.OS === 'ios') {\n  AppState.addEventListener('change', (e) => {\n    console.log('app state changed', e)\n    if(e === 'active')\n      RNFetchBlob.emitExpiredEvent(()=>{})\n  })\n}\n\n// register message channel event handler.\nemitter.addListener(\"RNFetchBlobMessage\", (e) => {\n\n  if(e.event === 'warn') {\n    console.warn(e.detail)\n  }\n  else if (e.event === 'error') {\n    throw e.detail\n  }\n  else {\n    console.log(\"RNFetchBlob native message\", e.detail)\n  }\n})\n\n// Show warning if native module not detected\nif(!RNFetchBlob || !RNFetchBlob.fetchBlobForm || !RNFetchBlob.fetchBlob) {\n  console.warn(\n    'react-native-fetch-blob could not find valid native module.',\n    'please make sure you have linked native modules using `rnpm link`,',\n    'and restart RN packager or manually compile IOS/Android project.'\n  )\n}\n\nfunction wrap(path:string):string {\n  return 'RNFetchBlob-file://' + path\n}\n\n/**\n * Calling this method will inject configurations into followed `fetch` method.\n * @param  {RNFetchBlobConfig} options\n *         Fetch API configurations, contains the following options :\n *         @property {boolean} fileCache\n *                   When fileCache is `true`, response data will be saved in\n *                   storage with a random generated file name, rather than\n *                   a BASE64 encoded string.\n *         @property {string} appendExt\n *                   Set this property to change file extension of random-\n *                   generated file name.\n *         @property {string} path\n *                   If this property has a valid string format, resonse data\n *                   will be saved to specific file path. Default string format\n *                   is : `RNFetchBlob-file://path-to-file`\n *         @property {string} key\n *                   If this property is set, it will be converted to md5, to\n *                   check if a file with this name exists.\n *                   If it exists, the absolute path is returned (no network\n *                   activity takes place )\n *                   If it doesn't exist, the file is downloaded as usual\n *         @property {number} timeout\n *                   Request timeout in millionseconds, by default it's 30000ms.\n *\n * @return {function} This method returns a `fetch` method instance.\n */\nfunction config (options:RNFetchBlobConfig) {\n  return { fetch : fetch.bind(options) }\n}\n\n/**\n * Fetch from file system, use the same interface as RNFB.fetch\n * @param  {RNFetchBlobConfig} [options={}] Fetch configurations\n * @param  {string} method     Should be one of `get`, `post`, `put`\n * @param  {string} url        A file URI string\n * @param  {string} headers    Arguments of file system API\n * @param  {any} body       Data to put or post to file systen.\n * @return {Promise}\n */\nfunction fetchFile(options = {}, method, url, headers = {}, body):Promise {\n\n  if(!URIUtil.isFileURI(url)) {\n    throw `could not fetch file from an invalid URI : ${url}`\n  }\n\n  url = URIUtil.unwrapFileURI(url)\n\n  let promise = null\n  let cursor = 0\n  let total = -1\n  let cacheData = ''\n  let info = null\n  let _progress, _uploadProgress, _stateChange\n\n  switch(method.toLowerCase()) {\n\n    case 'post':\n    break\n\n    case 'put':\n    break\n\n    // read data from file system\n    default:\n      promise = fs.stat(url)\n      .then((stat) => {\n        total = stat.size\n        return fs.readStream(url,\n          headers.encoding || 'utf8',\n          Math.floor(headers.bufferSize) || 409600,\n          Math.floor(headers.interval) || 100\n        )\n      })\n      .then((stream) => new Promise((resolve, reject) => {\n        stream.open()\n        info = {\n          state : \"2\",\n          headers : { 'source' : 'system-fs' },\n          status : 200,\n          respType : 'text',\n          rnfbEncode : headers.encoding || 'utf8'\n        }\n        _stateChange(info)\n        stream.onData((chunk) => {\n          _progress && _progress(cursor, total, chunk)\n          if(headers.noCache)\n            return\n          cacheData += chunk\n        })\n        stream.onError((err) => { reject(err) })\n        stream.onEnd(() => {\n          resolve(new FetchBlobResponse(null, info, cacheData))\n        })\n      }))\n    break\n  }\n\n  promise.progress = (fn) => {\n    _progress = fn\n    return promise\n  }\n  promise.stateChange = (fn) => {\n    _stateChange = fn\n    return promise\n  }\n  promise.uploadProgress = (fn) => {\n    _uploadProgress = fn\n    return promise\n  }\n\n  return promise\n}\n\n/**\n * Create a HTTP request by settings, the `this` context is a `RNFetchBlobConfig` object.\n * @param  {string} method HTTP method, should be `GET`, `POST`, `PUT`, `DELETE`\n * @param  {string} url Request target url string.\n * @param  {object} headers HTTP request headers.\n * @param  {string} body\n *         Request body, can be either a BASE64 encoded data string,\n *         or a file path with prefix `RNFetchBlob-file://` (can be changed)\n * @return {Promise}\n *         This promise instance also contains a Customized method `progress`for\n *         register progress event handler.\n */\nfunction fetch(...args:any):Promise {\n\n  // create task ID for receiving progress event\n  let taskId = getUUID()\n  let options = this || {}\n  let subscription, subscriptionUpload, stateEvent, partEvent\n  let respInfo = {}\n  let [method, url, headers, body] = [...args]\n\n  // # 241 normalize null or undefined headers, in case nil or null string\n  // pass to native context\n  headers = _.reduce(headers, (result, value, key) => {\n    result[key] = value || ''\n    return result\n  }, {});\n\n  // fetch from file system\n  if(URIUtil.isFileURI(url)) {\n    return fetchFile(options, method, url, headers, body)\n  }\n\n  // from remote HTTP(S)\n  let promise = new Promise((resolve, reject) => {\n    let nativeMethodName = Array.isArray(body) ? 'fetchBlobForm' : 'fetchBlob'\n\n    // on progress event listener\n    subscription = emitter.addListener('RNFetchBlobProgress', (e) => {\n      if(e.taskId === taskId && promise.onProgress) {\n        promise.onProgress(e.written, e.total, e.chunk)\n      }\n    })\n\n    subscriptionUpload = emitter.addListener('RNFetchBlobProgress-upload', (e) => {\n      if(e.taskId === taskId && promise.onUploadProgress) {\n        promise.onUploadProgress(e.written, e.total)\n      }\n    })\n\n    stateEvent = emitter.addListener('RNFetchBlobState', (e) => {\n      if(e.taskId === taskId)\n        respInfo = e\n      promise.onStateChange && promise.onStateChange(e)\n    })\n\n    subscription = emitter.addListener('RNFetchBlobExpire', (e) => {\n      if(e.taskId === taskId && promise.onExpire) {\n        promise.onExpire(e)\n      }\n    })\n\n    partEvent = emitter.addListener('RNFetchBlobServerPush', (e) => {\n      if(e.taskId === taskId && promise.onPartData) {\n        promise.onPartData(e.chunk)\n      }\n    })\n\n    // When the request body comes from Blob polyfill, we should use special its ref\n    // as the request body\n    if( body instanceof Blob && body.isRNFetchBlobPolyfill) {\n      body = body.getRNFetchBlobRef()\n    }\n\n    let req = RNFetchBlob[nativeMethodName]\n\n    /**\n     * Send request via native module, the response callback accepts three arguments\n     * @callback\n     * @param err {any} Error message or object, when the request success, this\n     *                  parameter should be `null`.\n     * @param rawType { 'utf8' | 'base64' | 'path'} RNFB request will be stored\n     *                  as UTF8 string, BASE64 string, or a file path reference\n     *                  in JS context, and this parameter indicates which one\n     *                  dose the response data presents.\n     * @param data {string} Response data or its reference.\n     */\n    req(options, taskId, method, url, headers || {}, body, (err, rawType, data) => {\n\n      // task done, remove event listeners\n      subscription.remove()\n      subscriptionUpload.remove()\n      stateEvent.remove()\n      partEvent.remove()\n      delete promise['progress']\n      delete promise['uploadProgress']\n      delete promise['stateChange']\n      delete promise['part']\n      delete promise['cancel']\n      // delete promise['expire']\n      promise.cancel = () => {}\n\n      if(err)\n        reject(new Error(err, respInfo))\n      else {\n        // response data is saved to storage, create a session for it\n        if(options.path || options.fileCache || options.addAndroidDownloads\n          || options.key || options.auto && respInfo.respType === 'blob') {\n          if(options.session)\n            session(options.session).add(data)\n        }\n        respInfo.rnfbEncode = rawType\n        resolve(new FetchBlobResponse(taskId, respInfo, data))\n      }\n\n    })\n\n  })\n\n  // extend Promise object, add `progress`, `uploadProgress`, and `cancel`\n  // method for register progress event handler and cancel request.\n  // Add second parameter for performance purpose #140\n  // When there's only one argument pass to this method, use default `interval`\n  // and `count`, otherwise use the given on.\n  // TODO : code refactor, move `uploadProgress` and `progress` to StatefulPromise\n  promise.progress = (...args) => {\n    let interval = 250\n    let count = -1\n    let fn = () => {}\n    if(args.length === 2) {\n      interval = args[0].interval || interval\n      count = args[0].count || count\n      fn = args[1]\n    }\n    else {\n      fn = args[0]\n    }\n    promise.onProgress = fn\n    RNFetchBlob.enableProgressReport(taskId, interval, count)\n    return promise\n  }\n  promise.uploadProgress = (...args) => {\n    let interval = 250\n    let count = -1\n    let fn = () => {}\n    if(args.length === 2) {\n      interval = args[0].interval || interval\n      count = args[0].count || count\n      fn = args[1]\n    }\n    else {\n      fn = args[0]\n    }\n    promise.onUploadProgress = fn\n    RNFetchBlob.enableUploadProgressReport(taskId, interval, count)\n    return promise\n  }\n  promise.part = (fn) => {\n    promise.onPartData = fn\n    return promise\n  }\n  promise.stateChange = (fn) => {\n    promise.onStateChange = fn\n    return promise\n  }\n  promise.expire = (fn) => {\n    promise.onExpire = fn\n    return promise\n  }\n  promise.cancel = (fn) => {\n    fn = fn || function(){}\n    subscription.remove()\n    subscriptionUpload.remove()\n    stateEvent.remove()\n    RNFetchBlob.cancelRequest(taskId, fn)\n  }\n  promise.taskId = taskId\n\n  return promise\n\n}\n\n/**\n * RNFetchBlob response object class.\n */\nclass FetchBlobResponse {\n\n  taskId : string;\n  path : () => string | null;\n  type : 'base64' | 'path' | 'utf8';\n  data : any;\n  blob : (contentType:string, sliceSize:number) => Promise<Blob>;\n  text : () => string | Promise<any>;\n  json : () => any;\n  base64 : () => any;\n  flush : () => void;\n  respInfo : RNFetchBlobResponseInfo;\n  session : (name:string) => RNFetchBlobSession | null;\n  readFile : (encode: 'base64' | 'utf8' | 'ascii') => ?Promise<any>;\n  readStream : (\n    encode: 'utf8' | 'ascii' | 'base64',\n  ) => RNFetchBlobStream | null;\n\n  constructor(taskId:string, info:RNFetchBlobResponseInfo, data:any) {\n    this.data = data\n    this.taskId = taskId\n    this.type = info.rnfbEncode\n    this.respInfo = info\n\n    this.info = ():RNFetchBlobResponseInfo => {\n      return this.respInfo\n    }\n\n    this.array = ():Promise<Array> => {\n      let cType = info.headers['Content-Type'] || info.headers['content-type']\n      return new Promise((resolve, reject) => {\n        switch(this.type) {\n          case 'base64':\n            // TODO : base64 to array buffer\n          break\n          case 'path':\n            fs.readFile(this.data, 'ascii').then(resolve)\n          break\n          default:\n            // TODO : text to array buffer\n          break\n        }\n      })\n    }\n\n    /**\n     * Convert result to javascript RNFetchBlob object.\n     * @return {Promise<Blob>} Return a promise resolves Blob object.\n     */\n    this.blob = ():Promise<Blob> => {\n      let Blob = polyfill.Blob\n      let cType = info.headers['Content-Type'] || info.headers['content-type']\n      return new Promise((resolve, reject) => {\n        switch(this.type) {\n          case 'base64':\n            Blob.build(this.data, { type : cType + ';BASE64' }).then(resolve)\n          break\n          case 'path':\n            polyfill.Blob.build(wrap(this.data), { type : cType }).then(resolve)\n          break\n          default:\n            polyfill.Blob.build(this.data, { type : 'text/plain' }).then(resolve)\n          break\n        }\n      })\n    }\n    /**\n     * Convert result to text.\n     * @return {string} Decoded base64 string.\n     */\n    this.text = ():string | Promise<any> => {\n      let res = this.data\n      switch(this.type) {\n        case 'base64':\n          return base64.decode(this.data)\n        case 'path':\n          return fs.readFile(this.data, 'base64').then((b64) => Promise.resolve(base64.decode(b64)))\n        default:\n          return this.data\n      }\n    }\n    /**\n     * Convert result to JSON object.\n     * @return {object} Parsed javascript object.\n     */\n    this.json = ():any => {\n      switch(this.type) {\n        case 'base64':\n          return JSON.parse(base64.decode(this.data))\n        case 'path':\n          return fs.readFile(this.data, 'utf8')\n                   .then((text) => Promise.resolve(JSON.parse(text)))\n        default:\n          return JSON.parse(this.data)\n      }\n    }\n    /**\n     * Return BASE64 string directly.\n     * @return {string} BASE64 string of response body.\n     */\n    this.base64 = ():string | Promise<any> => {\n      switch(this.type) {\n        case 'base64':\n          return this.data\n        case 'path':\n          return fs.readFile(this.data, 'base64')\n        default:\n          return base64.encode(this.data)\n      }\n    }\n    /**\n     * Remove cahced file\n     * @return {Promise}\n     */\n    this.flush = () => {\n      let path = this.path()\n      if(!path || this.type !== 'path')\n        return\n      return unlink(path)\n    }\n    /**\n     * get path of response temp file\n     * @return {string} File path of temp file.\n     */\n    this.path = () => {\n      if(this.type === 'path')\n        return this.data\n      return null\n    }\n\n    this.session = (name:string):RNFetchBlobSession | null => {\n      if(this.type === 'path')\n        return session(name).add(this.data)\n      else {\n        console.warn('only file paths can be add into session.')\n        return null\n      }\n    }\n    /**\n     * Start read stream from cached file\n     * @param  {String} encoding Encode type, should be one of `base64`, `ascrii`, `utf8`.\n     * @param  {Function} fn On data event handler\n     * @return {void}\n     */\n    this.readStream = (encode: 'base64' | 'utf8' | 'ascii'):RNFetchBlobStream | null => {\n      if(this.type === 'path') {\n        return readStream(this.data, encode)\n      }\n      else {\n        console.warn('RNFetchblob', 'this response data does not contains any available stream')\n        return null\n      }\n    }\n    /**\n     * Read file content with given encoding, if the response does not contains\n     * a file path, show warning message\n     * @param  {String} encoding Encode type, should be one of `base64`, `ascrii`, `utf8`.\n     * @return {String}\n     */\n    this.readFile = (encode: 'base64' | 'utf8' | 'ascii') => {\n      if(this.type === 'path') {\n        encode = encode || 'utf8'\n        return readFile(this.data, encode)\n      }\n      else {\n        console.warn('RNFetchblob', 'this response does not contains a readable file')\n        return null\n      }\n    }\n  }\n\n}\n\nexport default {\n  fetch,\n  base64,\n  android,\n  ios,\n  config,\n  session,\n  fs,\n  wrap,\n  net,\n  polyfill,\n  JSONStream\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/android.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  Platform,\n  NativeAppEventEmitter,\n} from 'react-native'\n\nconst RNFetchBlob:RNFetchBlobNative = NativeModules.RNFetchBlob\n\n/**\n * Send an intent to open the file.\n * @param  {string]} path Path of the file to be open.\n * @param  {string} mime MIME type string\n * @return {Promise}\n */\nfunction actionViewIntent(path:string, mime:string = 'text/plain') {\n  if(Platform.OS === 'android')\n    return RNFetchBlob.actionViewIntent(path, mime)\n  else\n    return Promise.reject('RNFetchBlob.actionViewIntent only supports Android.')\n}\n\n\nexport default {\n  actionViewIntent\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/fs.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  Platform,\n  NativeAppEventEmitter,\n} from 'react-native'\nimport RNFetchBlobSession from './class/RNFetchBlobSession'\nimport RNFetchBlobWriteStream from './class/RNFetchBlobWriteStream'\nimport RNFetchBlobReadStream from './class/RNFetchBlobReadStream'\nimport RNFetchBlobFile from './class/RNFetchBlobFile'\nimport type {\n  RNFetchBlobNative,\n  RNFetchBlobConfig,\n  RNFetchBlobStream\n} from './types'\n\nconst RNFetchBlob:RNFetchBlobNative = NativeModules.RNFetchBlob\nconst emitter = DeviceEventEmitter\nconst dirs = {\n    DocumentDir :  RNFetchBlob.DocumentDir,\n    CacheDir : RNFetchBlob.CacheDir,\n    PictureDir : RNFetchBlob.PictureDir,\n    MusicDir : RNFetchBlob.MusicDir,\n    MovieDir : RNFetchBlob.MovieDir,\n    DownloadDir : RNFetchBlob.DownloadDir,\n    DCIMDir : RNFetchBlob.DCIMDir,\n    SDCardDir : RNFetchBlob.SDCardDir,\n    MainBundleDir : RNFetchBlob.MainBundleDir\n}\n\n/**\n * Get a file cache session\n * @param  {string} name Stream ID\n * @return {RNFetchBlobSession}\n */\nfunction session(name:string):RNFetchBlobSession {\n  let s = RNFetchBlobSession.getSession(name)\n  if(s)\n    return new RNFetchBlobSession(name)\n  else {\n    RNFetchBlobSession.setSession(name, [])\n    return new RNFetchBlobSession(name, [])\n  }\n}\n\nfunction asset(path:string):string {\n  if(Platform.OS === 'ios') {\n    // path from camera roll\n    if(/^assets-library\\:\\/\\//.test(path))\n      return path\n  }\n  return 'bundle-assets://' + path\n}\n\nfunction createFile(path:string, data:string, encoding: 'base64' | 'ascii' | 'utf8'):Promise {\n  encoding = encoding || 'utf8'\n  return new Promise((resolve, reject) => {\n    let handler = (err) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve()\n    }\n    if(encoding.toLowerCase() === 'ascii') {\n      if(Array.isArray(data))\n        RNFetchBlob.createFileASCII(path, data, handler)\n      else\n        reject(new Error('`data` of ASCII file must be an array contains numbers'))\n    }\n    else {\n      RNFetchBlob.createFile(path, data, encoding, handler)\n    }\n  })\n}\n\n/**\n * Create write stream to a file.\n * @param  {string} path Target path of file stream.\n * @param  {string} encoding Encoding of input data.\n * @param  {bool} append  A flag represent if data append to existing ones.\n * @return {Promise<WriteStream>} A promise resolves a `WriteStream` object.\n */\nfunction writeStream(\n  path : string,\n  encoding : 'utf8' | 'ascii' | 'base64',\n  append? : ?bool,\n):Promise<RNFetchBlobWriteStream> {\n  if(!path)\n    throw Error('RNFetchBlob could not open file stream with empty `path`')\n  encoding = encoding || 'utf8'\n  append = append || false\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.writeStream(path, encoding || 'base64', append || false, (err, streamId:string) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve(new RNFetchBlobWriteStream(streamId, encoding))\n    })\n  })\n}\n\n/**\n * Create file stream from file at `path`.\n * @param  {string} path   The file path.\n * @param  {string} encoding Data encoding, should be one of `base64`, `utf8`, `ascii`\n * @param  {boolean} bufferSize Size of stream buffer.\n * @return {RNFetchBlobStream} RNFetchBlobStream stream instance.\n */\nfunction readStream(\n  path : string,\n  encoding : 'utf8' | 'ascii' | 'base64',\n  bufferSize? : ?number,\n  tick : ?number = 10\n):Promise<RNFetchBlobReadStream> {\n  return Promise.resolve(new RNFetchBlobReadStream(path, encoding, bufferSize, tick))\n}\n\n/**\n * Create a directory.\n * @param  {string} path Path of directory to be created\n * @return {Promise}\n */\nfunction mkdir(path:string):Promise {\n\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.mkdir(path, (err, res) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve()\n    })\n  })\n\n}\n\n/**\n * Wrapper method of readStream.\n * @param  {string} path Path of the file.\n * @param  {'base64' | 'utf8' | 'ascii'} encoding Encoding of read stream.\n * @return {Promise<Array<number> | string>}\n */\nfunction readFile(path:string, encoding:string, bufferSize:?number):Promise<any> {\n  if(typeof path !== 'string')\n    return Promise.reject(new Error('Invalid argument \"path\" '))\n  return RNFetchBlob.readFile(path, encoding)\n}\n\n/**\n * Write data to file.\n * @param  {string} path  Path of the file.\n * @param  {string | number[]} data Data to write to the file.\n * @param  {string} encoding Encoding of data (Optional).\n * @return {Promise}\n */\nfunction writeFile(path:string, data:string | Array<number>, encoding:?string):Promise {\n  encoding = encoding || 'utf8'\n  if(typeof path !== 'string')\n    return Promise.reject('Invalid argument \"path\" ')\n  if(encoding.toLocaleLowerCase() === 'ascii') {\n    if(!Array.isArray(data))\n      Promise.reject(new Error(`Expected \"data\" is an Array when encoding is \"ascii\", however got ${typeof data}`))\n    else\n      return RNFetchBlob.writeFileArray(path, data, false);\n  } else {\n    if(typeof data !== 'string')\n      Promise.reject(new Error(`Expected \"data\" is a String when encoding is \"utf8\" or \"base64\", however got ${typeof data}`))\n    else\n      return RNFetchBlob.writeFile(path, encoding, data, false);\n  }\n}\n\nfunction appendFile(path:string, data:string | Array<number>, encoding:?string):Promise {\n  encoding = encoding || 'utf8'\n  if(typeof path !== 'string')\n    return Promise.reject('Invalid argument \"path\" ')\n  if(encoding.toLocaleLowerCase() === 'ascii') {\n    if(!Array.isArray(data))\n      Promise.reject(new Error(`Expected \"data\" is an Array when encoding is \"ascii\", however got ${typeof data}`))\n    else\n      return RNFetchBlob.writeFileArray(path, data, true);\n  } else {\n    if(typeof data !== 'string')\n      Promise.reject(new Error(`Expected \"data\" is a String when encoding is \"utf8\" or \"base64\", however got ${typeof data}`))\n    else\n      return RNFetchBlob.writeFile(path, encoding, data, true);\n  }\n}\n\n/**\n * Show statistic data of a path.\n * @param  {string} path Target path\n * @return {RNFetchBlobFile}\n */\nfunction stat(path:string):Promise<RNFetchBlobFile> {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.stat(path, (err, stat) => {\n      if(err)\n        reject(new Error(err))\n      else {\n        if(stat) {\n          stat.size = parseInt(stat.size)\n          stat.lastModified = parseInt(stat.lastModified)\n        }\n        resolve(stat)\n      }\n    })\n  })\n}\n\n/**\n * Android only method, request media scanner to scan the file.\n * @param  {Array<Object<string, string>>} Array contains Key value pairs with key `path` and `mime`.\n * @return {Promise}\n */\nfunction scanFile(pairs:any):Promise {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.scanFile(pairs, (err) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve()\n    })\n  })\n}\n\nfunction cp(path:string, dest:string):Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.cp(path, dest, (err, res) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve(res)\n    })\n  })\n}\n\nfunction mv(path:string, dest:string):Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.mv(path, dest, (err, res) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve(res)\n    })\n  })\n}\n\nfunction lstat(path:string):Promise<Array<RNFetchBlobFile>> {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.lstat(path, (err, stat) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve(stat)\n    })\n  })\n}\n\nfunction ls(path:string):Promise<Array<String>> {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.ls(path, (err, res) => {\n      if(err)\n        reject(new Error(err))\n      else\n        resolve(res)\n    })\n  })\n}\n\n/**\n * Remove file at path.\n * @param  {string}   path:string Path of target file.\n * @return {Promise}\n */\nfunction unlink(path:string):Promise {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.unlink(path, (err) => {\n      if(err) {\n        reject(new Error(err))\n      }\n      else\n        resolve()\n    })\n  })\n}\n\n/**\n * Check if file exists and if it is a folder.\n * @param  {string} path Path to check\n * @return {Promise<bool, bool>}\n */\nfunction exists(path:string):Promise<bool, bool> {\n\n  return new Promise((resolve, reject) => {\n    try {\n      RNFetchBlob.exists(path, (exist) => {\n        resolve(exist)\n      })\n    } catch(err) {\n      reject(new Error(err))\n    }\n  })\n\n}\n\nfunction slice(src:string, dest:string, start:number, end:number):Promise {\n  let p = Promise.resolve()\n  let size = 0\n  function normalize(num, size) {\n    if(num < 0)\n      return Math.max(0, size + num)\n    if(!num && num !== 0)\n      return size\n    return num\n  }\n  if(start < 0 || end < 0 || !start || !end) {\n    p = p.then(() => stat(src))\n         .then((stat) => {\n           size = Math.floor(stat.size)\n           start = normalize(start || 0, size)\n           end = normalize(end, size)\n           return Promise.resolve()\n         })\n  }\n  return p.then(() => RNFetchBlob.slice(src, dest, start, end))\n}\n\nfunction isDir(path:string):Promise<bool, bool> {\n\n  return new Promise((resolve, reject) => {\n    try {\n      RNFetchBlob.exists(path, (exist, isDir) => {\n        resolve(isDir)\n      })\n    } catch(err) {\n      reject(new Error(err))\n    }\n  })\n\n}\n\nfunction df():Promise<{ free : number, total : number }> {\n  return new Promise((resolve, reject) => {\n    RNFetchBlob.df((err, stat) => {\n      if(err)\n        reject(err)\n      else\n        resolve(stat)\n    })\n  })\n}\n\nexport default {\n  RNFetchBlobSession,\n  unlink,\n  mkdir,\n  session,\n  ls,\n  readStream,\n  mv,\n  cp,\n  writeStream,\n  writeFile,\n  appendFile,\n  readFile,\n  exists,\n  createFile,\n  isDir,\n  stat,\n  lstat,\n  scanFile,\n  dirs,\n  slice,\n  asset,\n  df\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/ios.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  Platform,\n  NativeAppEventEmitter,\n} from 'react-native'\n\nconst RNFetchBlob:RNFetchBlobNative = NativeModules.RNFetchBlob\n\n/**\n * Open a file using UIDocumentInteractionController\n * @param  {string]} path Path of the file to be open.\n * @param  {string} scheme URI scheme that needs to support, optional\n * @return {Promise}\n */\nfunction previewDocument(path:string, scheme:string) {\n  if(Platform.OS === 'ios')\n    return RNFetchBlob.previewDocument('file://' + path, scheme)\n  else\n    return Promise.reject('RNFetchBlob.openDocument only supports IOS.')\n}\n\n/**\n * Preview a file using UIDocumentInteractionController\n * @param  {string]} path Path of the file to be open.\n * @param  {string} scheme URI scheme that needs to support, optional\n * @return {Promise}\n */\nfunction openDocument(path:string, scheme:string) {\n  if(Platform.OS === 'ios')\n    return RNFetchBlob.openDocument('file://' + path, scheme)\n  else\n    return Promise.reject('RNFetchBlob.previewDocument only supports IOS.')\n}\n\n/**\n * Set excludeFromBackupKey to a URL to prevent the resource to be backuped to\n * iCloud.\n * @param  {string} url URL of the resource, only file URL is supported\n * @return {Promise}\n */\nfunction excludeFromBackupKey(url:string) {\n  return RNFetchBlob.excludeFromBackupKey('file://' + path);\n}\n\nexport default {\n  openDocument,\n  previewDocument,\n  excludeFromBackupKey\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/json-stream.js":"import Oboe from './lib/oboe-browser.min.js'\nimport XMLHttpRequest from './polyfill/XMLHttpRequest'\nimport URIUtil from './utils/uri'\n\nconst OboeExtended = (arg: string | object) => {\n\n\n  window.location = ''\n\n  if(!window.XMLHttpRequest.isRNFBPolyfill ) {\n    window.XMLHttpRequest = XMLHttpRequest\n    console.warn('Use JSONStream will automatically replace window.XMLHttpRequest with RNFetchBlob.polyfill.XMLHttpRequest. You are seeing this warning because you did not replace it maually.')\n  }\n\n  if(typeof arg === 'string') {\n    if(URIUtil.isFileURI(arg)) {\n      arg = {\n        url : 'JSONStream://' + arg,\n        headers : { noCache : true }\n      }\n    }\n    else\n      arg = 'JSONStream://' + arg\n\n  }\n  else if(typeof arg === 'object') {\n    let headers = arg.headers || {}\n    if(URIUtil.isFileURI(arg.url)) {\n      headers.noCache = true\n    }\n    arg = Object.assign(arg, {\n      url : 'JSONStream://' + arg.url,\n      headers\n    })\n  }\n  return Oboe(arg)\n}\n\nexport default OboeExtended\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/net.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  Platform,\n  NativeAppEventEmitter,\n} from 'react-native'\n\nconst RNFetchBlob = NativeModules.RNFetchBlob\n\n/**\n * Get cookie according to the given url.\n * @param  {string} domain Domain of the cookies to be removed, remove all\n * @return {Promise<Array<String>>}     Cookies of a specific domain.\n */\nfunction getCookies(domain:string):Promise<Array<String>> {\n  return RNFetchBlob.getCookies(domain || '')\n}\n\n/**\n * Remove cookies for a specific domain\n * @param  {?string} domain Domain of the cookies to be removed, remove all\n * cookies when this is null.\n * @return {Promise<null>}\n */\nfunction removeCookies(domain:?string):Promise<null> {\n  return RNFetchBlob.removeCookies(domain || '')\n}\n\nexport default {\n  getCookies,\n  removeCookies\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/types.js":"\ntype RNFetchBlobConfig = {\n  fileCache : bool,\n  path : string,\n  appendExt : string,\n  session : string,\n  addAndroidDownloads : any,\n  indicator : bool\n};\n\ntype RNFetchBlobNative = {\n  // API for fetch octet-stream data\n  fetchBlob : (\n    options:fetchConfig,\n    taskId:string,\n    method:string,\n    url:string,\n    headers:any,\n    body:any,\n    callback:(err:any, ...data:any) => void\n  ) => void,\n  // API for fetch form data\n  fetchBlobForm : (\n    options:fetchConfig,\n    taskId:string,\n    method:string,\n    url:string,\n    headers:any,\n    form:Array<any>,\n    callback:(err:any, ...data:any) => void\n  ) => void,\n  // open file stream\n  readStream : (\n    path:string,\n    encode:'utf8' | 'ascii' | 'base64'\n  ) => void,\n  // get system folders\n  getEnvironmentDirs : (dirs:any) => void,\n  // unlink file by path\n  unlink : (path:string, callback: (err:any) => void) => void,\n  removeSession : (paths:Array<string>, callback: (err:any) => void) => void,\n  ls : (path:string, callback: (err:any) => void) => void,\n};\n\ntype RNFetchBlobResponseInfo = {\n  taskId : string,\n  state : number,\n  headers : any,\n  status : number,\n  respType : 'text' | 'blob' | '' | 'json',\n  rnfbEncode : 'path' | 'base64' | 'ascii' | 'utf8'\n}\n\ntype RNFetchBlobStream = {\n  onData : () => void,\n  onError : () => void,\n  onEnd : () => void,\n  _onData : () => void,\n  _onEnd : () => void,\n  _onError : () => void,\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/class/RNFetchBlobFile.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  NativeAppEventEmitter,\n} from 'react-native'\n\nconst RNFetchBlob = NativeModules.RNFetchBlob\nconst emitter = DeviceEventEmitter\n\nexport default class RNFetchBlobFile {\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/class/RNFetchBlobReadStream.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  NativeAppEventEmitter,\n} from 'react-native'\nimport UUID from '../utils/uuid'\n\nconst RNFetchBlob = NativeModules.RNFetchBlob\nconst emitter = DeviceEventEmitter\n\nexport default class RNFetchBlobReadStream {\n\n  path : string;\n  encoding : 'utf8' | 'ascii' | 'base64';\n  bufferSize : ?number;\n  closed : boolean;\n  tick : number = 10;\n\n  constructor(path:string, encoding:string, bufferSize?:?number, tick:number) {\n    if(!path)\n      throw Error('RNFetchBlob could not open file stream with empty `path`')\n    this.encoding = encoding || 'utf8'\n    this.bufferSize = bufferSize\n    this.path = path\n    this.closed = false\n    this.tick = tick\n    this._onData = () => {}\n    this._onEnd = () => {}\n    this._onError = () => {}\n    this.streamId = 'RNFBRS'+ UUID()\n\n    // register for file stream event\n    let subscription = emitter.addListener(this.streamId, (e) => {\n      let {event, detail} = e\n      if(this._onData && event === 'data') {\n        this._onData(detail)\n        return\n      }\n      else if (this._onEnd && event === 'end') {\n        this._onEnd(detail)\n      }\n      else {\n        if(this._onError)\n          this._onError(detail)\n        else\n          throw new Error(detail)\n      }\n      // when stream closed or error, remove event handler\n      if (event === 'error' || event === 'end') {\n        subscription.remove()\n        this.closed = true\n      }\n    })\n\n  }\n\n  open() {\n    if(!this.closed)\n      RNFetchBlob.readStream(this.path, this.encoding, this.bufferSize || 10240 , this.tick || -1, this.streamId)\n    else\n      throw new Error('Stream closed')\n  }\n\n  onData(fn:() => void) {\n    this._onData = fn\n  }\n\n  onError(fn) {\n    this._onError = fn\n  }\n\n  onEnd (fn) {\n    this._onEnd = fn\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/class/RNFetchBlobSession.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n NativeModules,\n DeviceEventEmitter,\n NativeAppEventEmitter,\n} from 'react-native'\n\nconst RNFetchBlob = NativeModules.RNFetchBlob\nconst emitter = DeviceEventEmitter\n\nlet sessions = {}\n\nexport default class RNFetchBlobSession {\n\n  add : (path:string) => RNFetchBlobSession;\n  remove : (path:string) => RNFetchBlobSession;\n  dispose : () => Promise;\n  list : () => Array<string>;\n  name : string;\n\n  static getSession(name:string):any {\n    return sessions[name]\n  }\n\n  static setSession(name:string, val:any) {\n    sessions[name] = val\n  }\n\n  static removeSession(name:string) {\n    delete sessions[name]\n  }\n\n  constructor(name:string, list:Array<string>) {\n    this.name = name\n    if(!sessions[name]) {\n      if(Array.isArray(list))\n      sessions[name] = list\n      else\n      sessions[name] = []\n    }\n  }\n\n  add(path:string):RNFetchBlobSession {\n    sessions[this.name].push(path)\n    return this\n  }\n\n  remove(path:string):RNFetchBlobSession {\n    let list = sessions[this.name]\n    for(let i in list) {\n      if(list[i] === path) {\n        sessions[this.name].splice(i, 1)\n        break;\n      }\n    }\n    return this\n  }\n\n  list():Array<string> {\n    return sessions[this.name]\n  }\n\n  dispose():Promise {\n    return new Promise((resolve, reject) => {\n      RNFetchBlob.removeSession(sessions[this.name], (err) => {\n        if(err)\n          reject(err)\n        else {\n          delete sessions[this.name]\n          resolve()\n        }\n      })\n    })\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/class/RNFetchBlobWriteStream.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n NativeModules,\n DeviceEventEmitter,\n NativeAppEventEmitter,\n} from 'react-native'\n\nconst RNFetchBlob = NativeModules.RNFetchBlob\nconst emitter = DeviceEventEmitter\n\nexport default class RNFetchBlobWriteStream {\n\n  id : string;\n  encoding : string;\n  append : bool;\n\n  constructor(streamId:string, encoding:string, append:string) {\n    this.id = streamId\n    this.encoding = encoding\n    this.append = append\n  }\n\n  write(data:string) {\n    return new Promise((resolve, reject) => {\n      try {\n        let method = this.encoding === 'ascii' ? 'writeArrayChunk' : 'writeChunk'\n        if(this.encoding.toLocaleLowerCase() === 'ascii' && !Array.isArray(data)) {\n            reject('ascii input data must be an Array')\n            return\n        }\n        RNFetchBlob[method](this.id, data, (error) => {\n          if(error)\n            reject(error)\n          else\n            resolve()\n        })\n      } catch(err) {\n        reject(err)\n      }\n    })\n  }\n\n  close() {\n    return new Promise((resolve, reject) => {\n      try {\n        RNFetchBlob.closeStream(this.id, () => {\n          resolve()\n        })\n      } catch (err) {\n        reject(err)\n      }\n    })\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/class/StatefulPromise.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nexport default class StatefulPromise extends Promise {\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/components/Fetch.onPress.js":"// press button to login\n{/*<Fetch.onPress method=\"POST\"\n  url=\"www.example.com/login\"\n  body={this.state.body}\n  onSuccess={this.onSuccess}\n  onError={this.showError}>\n  <View>\n  \t<Text>Click to Login</Text>\n  </View>\n</LoginAction.onPress>*/}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/components/Fetch.when.js":"// placeholder\n{/*<Fetch method=\"GET\"\n  url={`www.example.com/avatar/${this.state.userId}`}\n  onSuccess={(data) => { this.setState({avatar : data.path()}) }}\n  onError={this.showError}>\n  <Fetch.before>\n\t\t<Image souce=\"images/placeholder.png\"/>\n\t</Fetch.before>\n  <Fetch.success>\n\t\t<Image souce={this.state.avatar}/>\n\t</Fetch.success>\n  <Fetch.error>\n\t\t<Image souce=\"images/error.png\"/>\n\t</Fetch.error>\n</LoginAction.onPress>*/}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/lib/oboe-browser.js":"// This file is the concatenation of many js files.\n// See http://github.com/jimhigson/oboe.js for the raw source\n\n// having a local undefined, window, Object etc allows slightly better minification:\n(function  (window, Object, Array, Error, JSON, undefined ) {\n\n   // v2.1.1-1-gb70a959\n\n/*\n\nCopyright (c) 2013, Jim Higson\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1.  Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n2.  Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n/** \n * Partially complete a function.\n * \n *  var add3 = partialComplete( function add(a,b){return a+b}, 3 );\n *  \n *  add3(4) // gives 7\n *  \n *  function wrap(left, right, cen){return left + \" \" + cen + \" \" + right;}\n *  \n *  var pirateGreeting = partialComplete( wrap , \"I'm\", \", a mighty pirate!\" );\n *  \n *  pirateGreeting(\"Guybrush Threepwood\"); \n *  // gives \"I'm Guybrush Threepwood, a mighty pirate!\"\n */\nvar partialComplete = varArgs(function( fn, args ) {\n\n      // this isn't the shortest way to write this but it does\n      // avoid creating a new array each time to pass to fn.apply,\n      // otherwise could just call boundArgs.concat(callArgs)       \n\n      var numBoundArgs = args.length;\n\n      return varArgs(function( callArgs ) {\n         \n         for (var i = 0; i < callArgs.length; i++) {\n            args[numBoundArgs + i] = callArgs[i];\n         }\n         \n         args.length = numBoundArgs + callArgs.length;         \n                     \n         return fn.apply(this, args);\n      }); \n   }),\n\n/**\n * Compose zero or more functions:\n * \n *    compose(f1, f2, f3)(x) = f1(f2(f3(x))))\n * \n * The last (inner-most) function may take more than one parameter:\n * \n *    compose(f1, f2, f3)(x,y) = f1(f2(f3(x,y))))\n */\n   compose = varArgs(function(fns) {\n\n      var fnsList = arrayAsList(fns);\n   \n      function next(params, curFn) {  \n         return [apply(params, curFn)];   \n      }\n            \n      return varArgs(function(startParams){\n        \n         return foldR(next, startParams, fnsList)[0];\n      });\n   });\n\n/**\n * A more optimised version of compose that takes exactly two functions\n * @param f1\n * @param f2\n */\nfunction compose2(f1, f2){\n   return function(){\n      return f1.call(this,f2.apply(this,arguments));\n   }\n}\n\n/**\n * Generic form for a function to get a property from an object\n * \n *    var o = {\n *       foo:'bar'\n *    }\n *    \n *    var getFoo = attr('foo')\n *    \n *    fetFoo(o) // returns 'bar'\n * \n * @param {String} key the property name\n */\nfunction attr(key) {\n   return function(o) { return o[key]; };\n}\n        \n/**\n * Call a list of functions with the same args until one returns a \n * truthy result. Similar to the || operator.\n * \n * So:\n *      lazyUnion([f1,f2,f3 ... fn])( p1, p2 ... pn )\n *      \n * Is equivalent to: \n *      apply([p1, p2 ... pn], f1) || \n *      apply([p1, p2 ... pn], f2) || \n *      apply([p1, p2 ... pn], f3) ... apply(fn, [p1, p2 ... pn])  \n *  \n * @returns the first return value that is given that is truthy.\n */\n   var lazyUnion = varArgs(function(fns) {\n\n      return varArgs(function(params){\n   \n         var maybeValue;\n   \n         for (var i = 0; i < len(fns); i++) {\n   \n            maybeValue = apply(params, fns[i]);\n   \n            if( maybeValue ) {\n               return maybeValue;\n            }\n         }\n      });\n   });   \n\n/**\n * This file declares various pieces of functional programming.\n * \n * This isn't a general purpose functional library, to keep things small it\n * has just the parts useful for Oboe.js.\n */\n\n\n/**\n * Call a single function with the given arguments array.\n * Basically, a functional-style version of the OO-style Function#apply for \n * when we don't care about the context ('this') of the call.\n * \n * The order of arguments allows partial completion of the arguments array\n */\nfunction apply(args, fn) {\n   return fn.apply(undefined, args);\n}\n\n/**\n * Define variable argument functions but cut out all that tedious messing about \n * with the arguments object. Delivers the variable-length part of the arguments\n * list as an array.\n * \n * Eg:\n * \n * var myFunction = varArgs(\n *    function( fixedArgument, otherFixedArgument, variableNumberOfArguments ){\n *       console.log( variableNumberOfArguments );\n *    }\n * )\n * \n * myFunction('a', 'b', 1, 2, 3); // logs [1,2,3]\n * \n * var myOtherFunction = varArgs(function( variableNumberOfArguments ){\n *    console.log( variableNumberOfArguments );\n * })\n * \n * myFunction(1, 2, 3); // logs [1,2,3]\n * \n */\nfunction varArgs(fn){\n\n   var numberOfFixedArguments = fn.length -1,\n       slice = Array.prototype.slice;          \n         \n                   \n   if( numberOfFixedArguments == 0 ) {\n      // an optimised case for when there are no fixed args:   \n   \n      return function(){\n         return fn.call(this, slice.call(arguments));\n      }\n      \n   } else if( numberOfFixedArguments == 1 ) {\n      // an optimised case for when there are is one fixed args:\n   \n      return function(){\n         return fn.call(this, arguments[0], slice.call(arguments, 1));\n      }\n   }\n   \n   // general case   \n\n   // we know how many arguments fn will always take. Create a\n   // fixed-size array to hold that many, to be re-used on\n   // every call to the returned function\n   var argsHolder = Array(fn.length);   \n                             \n   return function(){\n                            \n      for (var i = 0; i < numberOfFixedArguments; i++) {\n         argsHolder[i] = arguments[i];         \n      }\n\n      argsHolder[numberOfFixedArguments] = \n         slice.call(arguments, numberOfFixedArguments);\n                                \n      return fn.apply( this, argsHolder);      \n   }       \n}\n\n\n/**\n * Swap the order of parameters to a binary function\n * \n * A bit like this flip: http://zvon.org/other/haskell/Outputprelude/flip_f.html\n */\nfunction flip(fn){\n   return function(a, b){\n      return fn(b,a);\n   }\n}\n\n\n/**\n * Create a function which is the intersection of two other functions.\n * \n * Like the && operator, if the first is truthy, the second is never called,\n * otherwise the return value from the second is returned.\n */\nfunction lazyIntersection(fn1, fn2) {\n\n   return function (param) {\n                                                              \n      return fn1(param) && fn2(param);\n   };   \n}\n\n/**\n * A function which does nothing\n */\nfunction noop(){}\n\n/**\n * A function which is always happy\n */\nfunction always(){return true}\n\n/**\n * Create a function which always returns the same\n * value\n * \n * var return3 = functor(3);\n * \n * return3() // gives 3\n * return3() // still gives 3\n * return3() // will always give 3\n */\nfunction functor(val){\n   return function(){\n      return val;\n   }\n}\n\n/**\n * This file defines some loosely associated syntactic sugar for \n * Javascript programming \n */\n\n\n/**\n * Returns true if the given candidate is of type T\n */\nfunction isOfType(T, maybeSomething){\n   return maybeSomething && maybeSomething.constructor === T;\n}\n\nvar len = attr('length'),    \n    isString = partialComplete(isOfType, String);\n\n/** \n * I don't like saying this:\n * \n *    foo !=== undefined\n *    \n * because of the double-negative. I find this:\n * \n *    defined(foo)\n *    \n * easier to read.\n */ \nfunction defined( value ) {\n   return value !== undefined;\n}\n\n/**\n * Returns true if object o has a key named like every property in \n * the properties array. Will give false if any are missing, or if o \n * is not an object.\n */\nfunction hasAllProperties(fieldList, o) {\n\n   return      (o instanceof Object) \n            &&\n               all(function (field) {         \n                  return (field in o);         \n               }, fieldList);\n}\n/**\n * Like cons in Lisp\n */\nfunction cons(x, xs) {\n   \n   /* Internally lists are linked 2-element Javascript arrays.\n          \n      Ideally the return here would be Object.freeze([x,xs])\n      so that bugs related to mutation are found fast.\n      However, cons is right on the critical path for\n      performance and this slows oboe-mark down by\n      ~25%. Under theoretical future JS engines that freeze more\n      efficiently (possibly even use immutability to\n      run faster) this should be considered for\n      restoration.\n   */\n   \n   return [x,xs];\n}\n\n/**\n * The empty list\n */\nvar emptyList = null,\n\n/**\n * Get the head of a list.\n * \n * Ie, head(cons(a,b)) = a\n */\n    head = attr(0),\n\n/**\n * Get the tail of a list.\n * \n * Ie, head(cons(a,b)) = a\n */\n    tail = attr(1);\n\n\n/** \n * Converts an array to a list \n * \n *    asList([a,b,c])\n * \n * is equivalent to:\n *    \n *    cons(a, cons(b, cons(c, emptyList))) \n **/\nfunction arrayAsList(inputArray){\n\n   return reverseList( \n      inputArray.reduce(\n         flip(cons),\n         emptyList \n      )\n   );\n}\n\n/**\n * A varargs version of arrayAsList. Works a bit like list\n * in LISP.\n * \n *    list(a,b,c) \n *    \n * is equivalent to:\n * \n *    cons(a, cons(b, cons(c, emptyList)))\n */\nvar list = varArgs(arrayAsList);\n\n/**\n * Convert a list back to a js native array\n */\nfunction listAsArray(list){\n\n   return foldR( function(arraySoFar, listItem){\n      \n      arraySoFar.unshift(listItem);\n      return arraySoFar;\n           \n   }, [], list );\n   \n}\n\n/**\n * Map a function over a list \n */\nfunction map(fn, list) {\n\n   return list\n            ? cons(fn(head(list)), map(fn,tail(list)))\n            : emptyList\n            ;\n}\n\n/**\n * foldR implementation. Reduce a list down to a single value.\n * \n * @pram {Function} fn     (rightEval, curVal) -> result \n */\nfunction foldR(fn, startValue, list) {\n      \n   return list \n            ? fn(foldR(fn, startValue, tail(list)), head(list))\n            : startValue\n            ;\n}\n\n/**\n * foldR implementation. Reduce a list down to a single value.\n * \n * @pram {Function} fn     (rightEval, curVal) -> result \n */\nfunction foldR1(fn, list) {\n      \n   return tail(list) \n            ? fn(foldR1(fn, tail(list)), head(list))\n            : head(list)\n            ;\n}\n\n\n/**\n * Return a list like the one given but with the first instance equal \n * to item removed \n */\nfunction without(list, test, removedFn) {\n \n   return withoutInner(list, removedFn || noop);\n \n   function withoutInner(subList, removedFn) {\n      return subList  \n         ?  ( test(head(subList)) \n                  ? (removedFn(head(subList)), tail(subList)) \n                  : cons(head(subList), withoutInner(tail(subList), removedFn))\n            )\n         : emptyList\n         ;\n   }               \n}\n\n/** \n * Returns true if the given function holds for every item in \n * the list, false otherwise \n */\nfunction all(fn, list) {\n   \n   return !list || \n          ( fn(head(list)) && all(fn, tail(list)) );\n}\n\n/**\n * Call every function in a list of functions with the same arguments\n * \n * This doesn't make any sense if we're doing pure functional because \n * it doesn't return anything. Hence, this is only really useful if the\n * functions being called have side-effects. \n */\nfunction applyEach(fnList, args) {\n\n   if( fnList ) {  \n      head(fnList).apply(null, args);\n      \n      applyEach(tail(fnList), args);\n   }\n}\n\n/**\n * Reverse the order of a list\n */\nfunction reverseList(list){ \n\n   // js re-implementation of 3rd solution from:\n   //    http://www.haskell.org/haskellwiki/99_questions/Solutions/5\n   function reverseInner( list, reversedAlready ) {\n      if( !list ) {\n         return reversedAlready;\n      }\n      \n      return reverseInner(tail(list), cons(head(list), reversedAlready))\n   }\n\n   return reverseInner(list, emptyList);\n}\n\nfunction first(test, list) {\n   return   list &&\n               (test(head(list)) \n                  ? head(list) \n                  : first(test,tail(list))); \n}\n\n/* \n   This is a slightly hacked-up browser only version of clarinet \n   \n      *  some features removed to help keep browser Oboe under \n         the 5k micro-library limit\n      *  plug directly into event bus\n   \n   For the original go here:\n      https://github.com/dscape/clarinet\n\n   We receive the events:\n      STREAM_DATA\n      STREAM_END\n      \n   We emit the events:\n      SAX_KEY\n      SAX_VALUE_OPEN\n      SAX_VALUE_CLOSE      \n      FAIL_EVENT      \n */\n\nfunction clarinet(eventBus) {\n  \"use strict\";\n   \n  var \n      // shortcut some events on the bus\n      emitSaxKey           = eventBus(SAX_KEY).emit,\n      emitValueOpen        = eventBus(SAX_VALUE_OPEN).emit,\n      emitValueClose       = eventBus(SAX_VALUE_CLOSE).emit,\n      emitFail             = eventBus(FAIL_EVENT).emit,\n              \n      MAX_BUFFER_LENGTH = 64 * 1024\n  ,   stringTokenPattern = /[\\\\\"\\n]/g\n  ,   _n = 0\n  \n      // states\n  ,   BEGIN                = _n++\n  ,   VALUE                = _n++ // general stuff\n  ,   OPEN_OBJECT          = _n++ // {\n  ,   CLOSE_OBJECT         = _n++ // }\n  ,   OPEN_ARRAY           = _n++ // [\n  ,   CLOSE_ARRAY          = _n++ // ]\n  ,   STRING               = _n++ // \"\"\n  ,   OPEN_KEY             = _n++ // , \"a\"\n  ,   CLOSE_KEY            = _n++ // :\n  ,   TRUE                 = _n++ // r\n  ,   TRUE2                = _n++ // u\n  ,   TRUE3                = _n++ // e\n  ,   FALSE                = _n++ // a\n  ,   FALSE2               = _n++ // l\n  ,   FALSE3               = _n++ // s\n  ,   FALSE4               = _n++ // e\n  ,   NULL                 = _n++ // u\n  ,   NULL2                = _n++ // l\n  ,   NULL3                = _n++ // l\n  ,   NUMBER_DECIMAL_POINT = _n++ // .\n  ,   NUMBER_DIGIT         = _n   // [0-9]\n\n      // setup initial parser values\n  ,   bufferCheckPosition  = MAX_BUFFER_LENGTH\n  ,   latestError                \n  ,   c                    \n  ,   p                    \n  ,   textNode             = \"\"\n  ,   numberNode           = \"\"     \n  ,   slashed              = false\n  ,   closed               = false\n  ,   state                = BEGIN\n  ,   stack                = []\n  ,   unicodeS             = null\n  ,   unicodeI             = 0\n  ,   depth                = 0\n  ,   position             = 0\n  ,   column               = 0  //mostly for error reporting\n  ,   line                 = 1\n  ;\n\n  function checkBufferLength () {\n     \n    var maxActual = 0;\n     \n    if (textNode.length > MAX_BUFFER_LENGTH) {\n      emitError(\"Max buffer length exceeded: textNode\");\n      maxActual = Math.max(maxActual, textNode.length);\n    }\n    if (numberNode.length > MAX_BUFFER_LENGTH) {\n      emitError(\"Max buffer length exceeded: numberNode\");\n      maxActual = Math.max(maxActual, numberNode.length);\n    }\n     \n    bufferCheckPosition = (MAX_BUFFER_LENGTH - maxActual)\n                               + position;\n  }\n\n  eventBus(STREAM_DATA).on(handleData);\n\n   /* At the end of the http content close the clarinet \n    This will provide an error if the total content provided was not \n    valid json, ie if not all arrays, objects and Strings closed properly */\n  eventBus(STREAM_END).on(handleStreamEnd);   \n\n  function emitError (errorString) {\n     if (textNode) {\n        emitValueOpen(textNode);\n        emitValueClose();\n        textNode = \"\";\n     }\n\n     latestError = Error(errorString + \"\\nLn: \"+line+\n                                       \"\\nCol: \"+column+\n                                       \"\\nChr: \"+c);\n     \n     emitFail(errorReport(undefined, undefined, latestError));\n  }\n\n  function handleStreamEnd() {\n    if( state == BEGIN ) {\n      // Handle the case where the stream closes without ever receiving\n      // any input. This isn't an error - response bodies can be blank,\n      // particularly for 204 http responses\n      \n      // Because of how Oboe is currently implemented, we parse a\n      // completely empty stream as containing an empty object.\n      // This is because Oboe's done event is only fired when the\n      // root object of the JSON stream closes.\n      \n      // This should be decoupled and attached instead to the input stream\n      // from the http (or whatever) resource ending.\n      // If this decoupling could happen the SAX parser could simply emit\n      // zero events on a completely empty input.\n      emitValueOpen({});\n      emitValueClose();\n\n      closed = true;\n      return;\n    }\n  \n    if (state !== VALUE || depth !== 0)\n      emitError(\"Unexpected end\");\n \n    if (textNode) {\n      emitValueOpen(textNode);\n      emitValueClose();\n      textNode = \"\";\n    }\n     \n    closed = true;\n  }\n\n  function whitespace(c){\n     return c == '\\r' || c == '\\n' || c == ' ' || c == '\\t';\n  }\n   \n  function handleData (chunk) {\n         \n    // this used to throw the error but inside Oboe we will have already\n    // gotten the error when it was emitted. The important thing is to\n    // not continue with the parse.\n    if (latestError)\n      return;\n      \n    if (closed) {\n       return emitError(\"Cannot write after close\");\n    }\n\n    var i = 0;\n    c = chunk[0]; \n\n    while (c) {\n      p = c;\n      c = chunk[i++];\n      if(!c) break;\n\n      position ++;\n      if (c == \"\\n\") {\n        line ++;\n        column = 0;\n      } else column ++;\n      switch (state) {\n\n        case BEGIN:\n          if (c === \"{\") state = OPEN_OBJECT;\n          else if (c === \"[\") state = OPEN_ARRAY;\n          else if (!whitespace(c))\n            return emitError(\"Non-whitespace before {[.\");\n        continue;\n\n        case OPEN_KEY:\n        case OPEN_OBJECT:\n          if (whitespace(c)) continue;\n          if(state === OPEN_KEY) stack.push(CLOSE_KEY);\n          else {\n            if(c === '}') {\n              emitValueOpen({});\n              emitValueClose();\n              state = stack.pop() || VALUE;\n              continue;\n            } else  stack.push(CLOSE_OBJECT);\n          }\n          if(c === '\"')\n             state = STRING;\n          else\n             return emitError(\"Malformed object key should start with \\\" \");\n        continue;\n\n        case CLOSE_KEY:\n        case CLOSE_OBJECT:\n          if (whitespace(c)) continue;\n\n          if(c===':') {\n            if(state === CLOSE_OBJECT) {\n              stack.push(CLOSE_OBJECT);\n\n               if (textNode) {\n                  // was previously (in upstream Clarinet) one event\n                  //  - object open came with the text of the first\n                  emitValueOpen({});\n                  emitSaxKey(textNode);\n                  textNode = \"\";\n               }\n               depth++;\n            } else {\n               if (textNode) {\n                  emitSaxKey(textNode);\n                  textNode = \"\";\n               }\n            }\n             state  = VALUE;\n          } else if (c==='}') {\n             if (textNode) {\n                emitValueOpen(textNode);\n                emitValueClose();\n                textNode = \"\";\n             }\n             emitValueClose();\n            depth--;\n            state = stack.pop() || VALUE;\n          } else if(c===',') {\n            if(state === CLOSE_OBJECT)\n              stack.push(CLOSE_OBJECT);\n             if (textNode) {\n                emitValueOpen(textNode);\n                emitValueClose();\n                textNode = \"\";\n             }\n             state  = OPEN_KEY;\n          } else \n             return emitError('Bad object');\n        continue;\n\n        case OPEN_ARRAY: // after an array there always a value\n        case VALUE:\n          if (whitespace(c)) continue;\n          if(state===OPEN_ARRAY) {\n            emitValueOpen([]);\n            depth++;             \n            state = VALUE;\n            if(c === ']') {\n              emitValueClose();\n              depth--;\n              state = stack.pop() || VALUE;\n              continue;\n            } else {\n              stack.push(CLOSE_ARRAY);\n            }\n          }\n               if(c === '\"') state = STRING;\n          else if(c === '{') state = OPEN_OBJECT;\n          else if(c === '[') state = OPEN_ARRAY;\n          else if(c === 't') state = TRUE;\n          else if(c === 'f') state = FALSE;\n          else if(c === 'n') state = NULL;\n          else if(c === '-') { // keep and continue\n            numberNode += c;\n          } else if(c==='0') {\n            numberNode += c;\n            state = NUMBER_DIGIT;\n          } else if('123456789'.indexOf(c) !== -1) {\n            numberNode += c;\n            state = NUMBER_DIGIT;\n          } else               \n            return emitError(\"Bad value\");\n        continue;\n\n        case CLOSE_ARRAY:\n          if(c===',') {\n            stack.push(CLOSE_ARRAY);\n             if (textNode) {\n                emitValueOpen(textNode);\n                emitValueClose();\n                textNode = \"\";\n             }\n             state  = VALUE;\n          } else if (c===']') {\n             if (textNode) {\n                emitValueOpen(textNode);\n                emitValueClose();\n                textNode = \"\";\n             }\n             emitValueClose();\n            depth--;\n            state = stack.pop() || VALUE;\n          } else if (whitespace(c))\n              continue;\n          else \n             return emitError('Bad array');\n        continue;\n\n        case STRING:\n          // thanks thejh, this is an about 50% performance improvement.\n          var starti              = i-1;\n           \n          STRING_BIGLOOP: while (true) {\n\n            // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n            while (unicodeI > 0) {\n              unicodeS += c;\n              c = chunk.charAt(i++);\n              if (unicodeI === 4) {\n                // TODO this might be slow? well, probably not used too often anyway\n                textNode += String.fromCharCode(parseInt(unicodeS, 16));\n                unicodeI = 0;\n                starti = i-1;\n              } else {\n                unicodeI++;\n              }\n              // we can just break here: no stuff we skipped that still has to be sliced out or so\n              if (!c) break STRING_BIGLOOP;\n            }\n            if (c === '\"' && !slashed) {\n              state = stack.pop() || VALUE;\n              textNode += chunk.substring(starti, i-1);\n              if(!textNode) {\n                 emitValueOpen(\"\");\n                 emitValueClose();\n              }\n              break;\n            }\n            if (c === '\\\\' && !slashed) {\n              slashed = true;\n              textNode += chunk.substring(starti, i-1);\n               c = chunk.charAt(i++);\n              if (!c) break;\n            }\n            if (slashed) {\n              slashed = false;\n                   if (c === 'n') { textNode += '\\n'; }\n              else if (c === 'r') { textNode += '\\r'; }\n              else if (c === 't') { textNode += '\\t'; }\n              else if (c === 'f') { textNode += '\\f'; }\n              else if (c === 'b') { textNode += '\\b'; }\n              else if (c === 'u') {\n                // \\uxxxx. meh!\n                unicodeI = 1;\n                unicodeS = '';\n              } else {\n                textNode += c;\n              }\n              c = chunk.charAt(i++);\n              starti = i-1;\n              if (!c) break;\n              else continue;\n            }\n\n            stringTokenPattern.lastIndex = i;\n            var reResult = stringTokenPattern.exec(chunk);\n            if (!reResult) {\n              i = chunk.length+1;\n              textNode += chunk.substring(starti, i-1);\n              break;\n            }\n            i = reResult.index+1;\n            c = chunk.charAt(reResult.index);\n            if (!c) {\n              textNode += chunk.substring(starti, i-1);\n              break;\n            }\n          }\n        continue;\n\n        case TRUE:\n          if (!c)  continue; // strange buffers\n          if (c==='r') state = TRUE2;\n          else\n             return emitError( 'Invalid true started with t'+ c);\n        continue;\n\n        case TRUE2:\n          if (!c)  continue;\n          if (c==='u') state = TRUE3;\n          else\n             return emitError('Invalid true started with tr'+ c);\n        continue;\n\n        case TRUE3:\n          if (!c) continue;\n          if(c==='e') {\n            emitValueOpen(true);\n            emitValueClose();\n            state = stack.pop() || VALUE;\n          } else\n             return emitError('Invalid true started with tru'+ c);\n        continue;\n\n        case FALSE:\n          if (!c)  continue;\n          if (c==='a') state = FALSE2;\n          else\n             return emitError('Invalid false started with f'+ c);\n        continue;\n\n        case FALSE2:\n          if (!c)  continue;\n          if (c==='l') state = FALSE3;\n          else\n             return emitError('Invalid false started with fa'+ c);\n        continue;\n\n        case FALSE3:\n          if (!c)  continue;\n          if (c==='s') state = FALSE4;\n          else\n             return emitError('Invalid false started with fal'+ c);\n        continue;\n\n        case FALSE4:\n          if (!c)  continue;\n          if (c==='e') {\n            emitValueOpen(false);\n            emitValueClose();\n            state = stack.pop() || VALUE;\n          } else\n             return emitError('Invalid false started with fals'+ c);\n        continue;\n\n        case NULL:\n          if (!c)  continue;\n          if (c==='u') state = NULL2;\n          else\n             return emitError('Invalid null started with n'+ c);\n        continue;\n\n        case NULL2:\n          if (!c)  continue;\n          if (c==='l') state = NULL3;\n          else\n             return emitError('Invalid null started with nu'+ c);\n        continue;\n\n        case NULL3:\n          if (!c) continue;\n          if(c==='l') {\n            emitValueOpen(null);\n            emitValueClose();\n            state = stack.pop() || VALUE;\n          } else \n             return emitError('Invalid null started with nul'+ c);\n        continue;\n\n        case NUMBER_DECIMAL_POINT:\n          if(c==='.') {\n            numberNode += c;\n            state       = NUMBER_DIGIT;\n          } else \n             return emitError('Leading zero not followed by .');\n        continue;\n\n        case NUMBER_DIGIT:\n          if('0123456789'.indexOf(c) !== -1) numberNode += c;\n          else if (c==='.') {\n            if(numberNode.indexOf('.')!==-1)\n               return emitError('Invalid number has two dots');\n            numberNode += c;\n          } else if (c==='e' || c==='E') {\n            if(numberNode.indexOf('e')!==-1 ||\n               numberNode.indexOf('E')!==-1 )\n               return emitError('Invalid number has two exponential');\n            numberNode += c;\n          } else if (c===\"+\" || c===\"-\") {\n            if(!(p==='e' || p==='E'))\n               return emitError('Invalid symbol in number');\n            numberNode += c;\n          } else {\n            if (numberNode) {\n              emitValueOpen(parseFloat(numberNode));\n              emitValueClose();\n              numberNode = \"\";\n            }\n            i--; // go back one\n            state = stack.pop() || VALUE;\n          }\n        continue;\n\n        default:\n          return emitError(\"Unknown state: \" + state);\n      }\n    }\n    if (position >= bufferCheckPosition)\n      checkBufferLength();\n  }\n}\n\n\n/** \n * A bridge used to assign stateless functions to listen to clarinet.\n * \n * As well as the parameter from clarinet, each callback will also be passed\n * the result of the last callback.\n * \n * This may also be used to clear all listeners by assigning zero handlers:\n * \n *    ascentManager( clarinet, {} )\n */\nfunction ascentManager(oboeBus, handlers){\n   \"use strict\";\n   \n   var listenerId = {},\n       ascent;\n\n   function stateAfter(handler) {\n      return function(param){\n         ascent = handler( ascent, param);\n      }\n   }\n   \n   for( var eventName in handlers ) {\n\n      oboeBus(eventName).on(stateAfter(handlers[eventName]), listenerId);\n   }\n   \n   oboeBus(NODE_SWAP).on(function(newNode) {\n      \n      var oldHead = head(ascent),\n          key = keyOf(oldHead),\n          ancestors = tail(ascent),\n          parentNode;\n\n      if( ancestors ) {\n         parentNode = nodeOf(head(ancestors));\n         parentNode[key] = newNode;\n      }\n   });\n\n   oboeBus(NODE_DROP).on(function() {\n\n      var oldHead = head(ascent),\n          key = keyOf(oldHead),\n          ancestors = tail(ascent),\n          parentNode;\n\n      if( ancestors ) {\n         parentNode = nodeOf(head(ancestors));\n \n         delete parentNode[key];\n      }\n   });\n\n   oboeBus(ABORTING).on(function(){\n      \n      for( var eventName in handlers ) {\n         oboeBus(eventName).un(listenerId);\n      }\n   });   \n}\n\n// based on gist https://gist.github.com/monsur/706839\n\n/**\n * XmlHttpRequest's getAllResponseHeaders() method returns a string of response\n * headers according to the format described here:\n * http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method\n * This method parses that string into a user-friendly key/value pair object.\n */\nfunction parseResponseHeaders(headerStr) {\n   var headers = {};\n   \n   headerStr && headerStr.split('\\u000d\\u000a')\n      .forEach(function(headerPair){\n   \n         // Can't use split() here because it does the wrong thing\n         // if the header value has the string \": \" in it.\n         var index = headerPair.indexOf('\\u003a\\u0020');\n         \n         headers[headerPair.substring(0, index)] \n                     = headerPair.substring(index + 2);\n      });\n   \n   return headers;\n}\n\n/**\n * Detect if a given URL is cross-origin in the scope of the\n * current page.\n * \n * Browser only (since cross-origin has no meaning in Node.js)\n *\n * @param {Object} pageLocation - as in window.location\n * @param {Object} ajaxHost - an object like window.location describing the \n *    origin of the url that we want to ajax in\n */\nfunction isCrossOrigin(pageLocation, ajaxHost) {\n\n   /*\n    * NB: defaultPort only knows http and https.\n    * Returns undefined otherwise.\n    */\n   function defaultPort(protocol) {\n      return {'http:':80, 'https:':443}[protocol];\n   }\n   \n   function portOf(location) {\n      // pageLocation should always have a protocol. ajaxHost if no port or\n      // protocol is specified, should use the port of the containing page\n      \n      return location.port || defaultPort(location.protocol||pageLocation.protocol);\n   }\n\n   // if ajaxHost doesn't give a domain, port is the same as pageLocation\n   // it can't give a protocol but not a domain\n   // it can't give a port but not a domain\n   \n   return !!(  (ajaxHost.protocol  && (ajaxHost.protocol  != pageLocation.protocol)) ||\n               (ajaxHost.host      && (ajaxHost.host      != pageLocation.host))     ||\n               (ajaxHost.host      && (portOf(ajaxHost) != portOf(pageLocation)))\n          );\n}\n\n/* turn any url into an object like window.location */\nfunction parseUrlOrigin(url) {\n   // url could be domain-relative\n   // url could give a domain\n\n   // cross origin means:\n   //    same domain\n   //    same port\n   //    some protocol\n   // so, same everything up to the first (single) slash \n   // if such is given\n   //\n   // can ignore everything after that   \n   \n   var URL_HOST_PATTERN = /(\\w+:)?(?:\\/\\/)([\\w.-]+)?(?::(\\d+))?\\/?/,\n\n         // if no match, use an empty array so that\n         // subexpressions 1,2,3 are all undefined\n         // and will ultimately return all empty\n         // strings as the parse result:\n       urlHostMatch = URL_HOST_PATTERN.exec(url) || [];\n   \n   return {\n      protocol:   urlHostMatch[1] || '',\n      host:       urlHostMatch[2] || '',\n      port:       urlHostMatch[3] || ''\n   };\n}\n\nfunction httpTransport(){\n   return new XMLHttpRequest();\n}\n\n/**\n * A wrapper around the browser XmlHttpRequest object that raises an \n * event whenever a new part of the response is available.\n * \n * In older browsers progressive reading is impossible so all the \n * content is given in a single call. For newer ones several events\n * should be raised, allowing progressive interpretation of the response.\n *      \n * @param {Function} oboeBus an event bus local to this Oboe instance\n * @param {XMLHttpRequest} xhr the xhr to use as the transport. Under normal\n *          operation, will have been created using httpTransport() above\n *          but for tests a stub can be provided instead.\n * @param {String} method one of 'GET' 'POST' 'PUT' 'PATCH' 'DELETE'\n * @param {String} url the url to make a request to\n * @param {String|Null} data some content to be sent with the request.\n *                      Only valid if method is POST or PUT.\n * @param {Object} [headers] the http request headers to send\n * @param {boolean} withCredentials the XHR withCredentials property will be\n *    set to this value\n */  \nfunction streamingHttp(oboeBus, xhr, method, url, data, headers, withCredentials) {\n           \n   \"use strict\";\n   \n   var emitStreamData = oboeBus(STREAM_DATA).emit,\n       emitFail       = oboeBus(FAIL_EVENT).emit,\n       numberOfCharsAlreadyGivenToCallback = 0,\n       stillToSendStartEvent = true;\n\n   // When an ABORTING message is put on the event bus abort \n   // the ajax request         \n   oboeBus( ABORTING ).on( function(){\n  \n      // if we keep the onreadystatechange while aborting the XHR gives \n      // a callback like a successful call so first remove this listener\n      // by assigning null:\n      xhr.onreadystatechange = null;\n            \n      xhr.abort();\n   });\n\n   /** \n    * Handle input from the underlying xhr: either a state change,\n    * the progress event or the request being complete.\n    */\n   function handleProgress() {\n                        \n      var textSoFar = xhr.responseText,\n          newText = textSoFar.substr(numberOfCharsAlreadyGivenToCallback);\n      \n      \n      /* Raise the event for new text.\n      \n         On older browsers, the new text is the whole response. \n         On newer/better ones, the fragment part that we got since \n         last progress. */\n         \n      if( newText ) {\n         emitStreamData( newText );\n      } \n\n      numberOfCharsAlreadyGivenToCallback = len(textSoFar);\n   }\n   \n   \n   if('onprogress' in xhr){  // detect browser support for progressive delivery\n      xhr.onprogress = handleProgress;\n   }\n      \n   xhr.onreadystatechange = function() {\n\n      function sendStartIfNotAlready() {\n         // Internet Explorer is very unreliable as to when xhr.status etc can\n         // be read so has to be protected with try/catch and tried again on \n         // the next readyState if it fails\n         try{\n            stillToSendStartEvent && oboeBus( HTTP_START ).emit(\n               xhr.status,\n               parseResponseHeaders(xhr.getAllResponseHeaders()) );\n            stillToSendStartEvent = false;\n         } catch(e){/* do nothing, will try again on next readyState*/}\n      }\n      \n      switch( xhr.readyState ) {\n               \n         case 2: // HEADERS_RECEIVED\n         case 3: // LOADING\n            return sendStartIfNotAlready();\n            \n         case 4: // DONE\n            sendStartIfNotAlready(); // if xhr.status hasn't been available yet, it must be NOW, huh IE?\n            \n            // is this a 2xx http code?\n            var successful = String(xhr.status)[0] == 2;\n            \n            if( successful ) {\n               // In Chrome 29 (not 28) no onprogress is emitted when a response\n               // is complete before the onload. We need to always do handleInput\n               // in case we get the load but have not had a final progress event.\n               // This looks like a bug and may change in future but let's take\n               // the safest approach and assume we might not have received a \n               // progress event for each part of the response\n               handleProgress();\n               \n               oboeBus(STREAM_END).emit();\n            } else {\n\n               emitFail( errorReport(\n                  xhr.status, \n                  xhr.responseText\n               ));\n            }\n      }\n   };\n   \n   try{\n   \n      xhr.open(method, url, true);\n   \n      for( var headerName in headers ){\n         xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n      \n      if( !isCrossOrigin(window.location, parseUrlOrigin(url)) ) {\n         xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n      }\n\n      xhr.withCredentials = withCredentials;\n      \n      xhr.send(data);\n      \n   } catch( e ) {\n      \n      // To keep a consistent interface with Node, we can't emit an event here.\n      // Node's streaming http adaptor receives the error as an asynchronous\n      // event rather than as an exception. If we emitted now, the Oboe user\n      // has had no chance to add a .fail listener so there is no way\n      // the event could be useful. For both these reasons defer the\n      // firing to the next JS frame.  \n      window.setTimeout(\n         partialComplete(emitFail, errorReport(undefined, undefined, e))\n      ,  0\n      );\n   }            \n}\n\nvar jsonPathSyntax = (function() {\n \n   var\n   \n   /** \n    * Export a regular expression as a simple function by exposing just \n    * the Regex#exec. This allows regex tests to be used under the same \n    * interface as differently implemented tests, or for a user of the\n    * tests to not concern themselves with their implementation as regular\n    * expressions.\n    * \n    * This could also be expressed point-free as:\n    *   Function.prototype.bind.bind(RegExp.prototype.exec),\n    *   \n    * But that's far too confusing! (and not even smaller once minified \n    * and gzipped)\n    */\n       regexDescriptor = function regexDescriptor(regex) {\n            return regex.exec.bind(regex);\n       }\n       \n   /**\n    * Join several regular expressions and express as a function.\n    * This allows the token patterns to reuse component regular expressions\n    * instead of being expressed in full using huge and confusing regular\n    * expressions.\n    */       \n   ,   jsonPathClause = varArgs(function( componentRegexes ) {\n\n            // The regular expressions all start with ^ because we \n            // only want to find matches at the start of the \n            // JSONPath fragment we are inspecting           \n            componentRegexes.unshift(/^/);\n            \n            return   regexDescriptor(\n                        RegExp(\n                           componentRegexes.map(attr('source')).join('')\n                        )\n                     );\n       })\n       \n   ,   possiblyCapturing =           /(\\$?)/\n   ,   namedNode =                   /([\\w-_]+|\\*)/\n   ,   namePlaceholder =             /()/\n   ,   nodeInArrayNotation =         /\\[\"([^\"]+)\"\\]/\n   ,   numberedNodeInArrayNotation = /\\[(\\d+|\\*)\\]/\n   ,   fieldList =                      /{([\\w ]*?)}/\n   ,   optionalFieldList =           /(?:{([\\w ]*?)})?/\n    \n\n       //   foo or *                  \n   ,   jsonPathNamedNodeInObjectNotation   = jsonPathClause( \n                                                possiblyCapturing, \n                                                namedNode, \n                                                optionalFieldList\n                                             )\n                                             \n       //   [\"foo\"]   \n   ,   jsonPathNamedNodeInArrayNotation    = jsonPathClause( \n                                                possiblyCapturing, \n                                                nodeInArrayNotation, \n                                                optionalFieldList\n                                             )  \n\n       //   [2] or [*]       \n   ,   jsonPathNumberedNodeInArrayNotation = jsonPathClause( \n                                                possiblyCapturing, \n                                                numberedNodeInArrayNotation, \n                                                optionalFieldList\n                                             )\n\n       //   {a b c}      \n   ,   jsonPathPureDuckTyping              = jsonPathClause( \n                                                possiblyCapturing, \n                                                namePlaceholder, \n                                                fieldList\n                                             )\n   \n       //   ..\n   ,   jsonPathDoubleDot                   = jsonPathClause(/\\.\\./)                  \n   \n       //   .\n   ,   jsonPathDot                         = jsonPathClause(/\\./)                    \n   \n       //   !\n   ,   jsonPathBang                        = jsonPathClause(\n                                                possiblyCapturing, \n                                                /!/\n                                             )  \n   \n       //   nada!\n   ,   emptyString                         = jsonPathClause(/$/)                     \n   \n   ;\n   \n  \n   /* We export only a single function. When called, this function injects \n      into another function the descriptors from above.             \n    */\n   return function (fn){      \n      return fn(      \n         lazyUnion(\n            jsonPathNamedNodeInObjectNotation\n         ,  jsonPathNamedNodeInArrayNotation\n         ,  jsonPathNumberedNodeInArrayNotation\n         ,  jsonPathPureDuckTyping \n         )\n      ,  jsonPathDoubleDot\n      ,  jsonPathDot\n      ,  jsonPathBang\n      ,  emptyString \n      );\n   }; \n\n}());\n/**\n * Get a new key->node mapping\n * \n * @param {String|Number} key\n * @param {Object|Array|String|Number|null} node a value found in the json\n */\nfunction namedNode(key, node) {\n   return {key:key, node:node};\n}\n\n/** get the key of a namedNode */\nvar keyOf = attr('key');\n\n/** get the node from a namedNode */\nvar nodeOf = attr('node');\n/** \n * This file provides various listeners which can be used to build up\n * a changing ascent based on the callbacks provided by Clarinet. It listens\n * to the low-level events from Clarinet and emits higher-level ones.\n *  \n * The building up is stateless so to track a JSON file\n * ascentManager.js is required to store the ascent state\n * between calls.\n */\n\n\n\n/** \n * A special value to use in the path list to represent the path 'to' a root \n * object (which doesn't really have any path). This prevents the need for \n * special-casing detection of the root object and allows it to be treated \n * like any other object. We might think of this as being similar to the \n * 'unnamed root' domain \".\", eg if I go to \n * http://en.wikipedia.org./wiki/En/Main_page the dot after 'org' deliminates \n * the unnamed root of the DNS.\n * \n * This is kept as an object to take advantage that in Javascript's OO objects \n * are guaranteed to be distinct, therefore no other object can possibly clash \n * with this one. Strings, numbers etc provide no such guarantee. \n **/\nvar ROOT_PATH = {};\n\n\n/**\n * Create a new set of handlers for clarinet's events, bound to the emit \n * function given.  \n */ \nfunction incrementalContentBuilder( oboeBus ) {\n\n   var emitNodeOpened = oboeBus(NODE_OPENED).emit,\n       emitNodeClosed = oboeBus(NODE_CLOSED).emit,\n       emitRootOpened = oboeBus(ROOT_PATH_FOUND).emit,\n       emitRootClosed = oboeBus(ROOT_NODE_FOUND).emit;\n\n   function arrayIndicesAreKeys( possiblyInconsistentAscent, newDeepestNode) {\n   \n      /* for values in arrays we aren't pre-warned of the coming paths \n         (Clarinet gives no call to onkey like it does for values in objects) \n         so if we are in an array we need to create this path ourselves. The \n         key will be len(parentNode) because array keys are always sequential \n         numbers. */\n\n      var parentNode = nodeOf( head( possiblyInconsistentAscent));\n      \n      return      isOfType( Array, parentNode)\n               ?\n                  keyFound(  possiblyInconsistentAscent, \n                              len(parentNode), \n                              newDeepestNode\n                  )\n               :  \n                  // nothing needed, return unchanged\n                  possiblyInconsistentAscent \n               ;\n   }\n                 \n   function nodeOpened( ascent, newDeepestNode ) {\n      \n      if( !ascent ) {\n         // we discovered the root node,         \n         emitRootOpened( newDeepestNode);\n                    \n         return keyFound( ascent, ROOT_PATH, newDeepestNode);         \n      }\n\n      // we discovered a non-root node\n                 \n      var arrayConsistentAscent  = arrayIndicesAreKeys( ascent, newDeepestNode),      \n          ancestorBranches       = tail( arrayConsistentAscent),\n          previouslyUnmappedName = keyOf( head( arrayConsistentAscent));\n          \n      appendBuiltContent( \n         ancestorBranches, \n         previouslyUnmappedName, \n         newDeepestNode \n      );\n                                                                                                         \n      return cons( \n               namedNode( previouslyUnmappedName, newDeepestNode ), \n               ancestorBranches\n      );                                                                          \n   }\n\n\n   /**\n    * Add a new value to the object we are building up to represent the\n    * parsed JSON\n    */\n   function appendBuiltContent( ancestorBranches, key, node ){\n     \n      nodeOf( head( ancestorBranches))[key] = node;\n   }\n\n     \n   /**\n    * For when we find a new key in the json.\n    * \n    * @param {String|Number|Object} newDeepestName the key. If we are in an \n    *    array will be a number, otherwise a string. May take the special \n    *    value ROOT_PATH if the root node has just been found\n    *    \n    * @param {String|Number|Object|Array|Null|undefined} [maybeNewDeepestNode] \n    *    usually this won't be known so can be undefined. Can't use null \n    *    to represent unknown because null is a valid value in JSON\n    **/  \n   function keyFound(ascent, newDeepestName, maybeNewDeepestNode) {\n\n      if( ascent ) { // if not root\n      \n         // If we have the key but (unless adding to an array) no known value\n         // yet. Put that key in the output but against no defined value:      \n         appendBuiltContent( ascent, newDeepestName, maybeNewDeepestNode );\n      }\n   \n      var ascentWithNewPath = cons( \n                                 namedNode( newDeepestName, \n                                            maybeNewDeepestNode), \n                                 ascent\n                              );\n\n      emitNodeOpened( ascentWithNewPath);\n \n      return ascentWithNewPath;\n   }\n\n\n   /**\n    * For when the current node ends.\n    */\n   function nodeClosed( ascent ) {\n\n      emitNodeClosed( ascent);\n       \n      return tail( ascent) ||\n             // If there are no nodes left in the ascent the root node\n             // just closed. Emit a special event for this: \n             emitRootClosed(nodeOf(head(ascent)));\n   }      \n\n   var contentBuilderHandlers = {};\n   contentBuilderHandlers[SAX_VALUE_OPEN] = nodeOpened;\n   contentBuilderHandlers[SAX_VALUE_CLOSE] = nodeClosed;\n   contentBuilderHandlers[SAX_KEY] = keyFound;\n   return contentBuilderHandlers;\n}\n\n/**\n * The jsonPath evaluator compiler used for Oboe.js. \n * \n * One function is exposed. This function takes a String JSONPath spec and \n * returns a function to test candidate ascents for matches.\n * \n *  String jsonPath -> (List ascent) -> Boolean|Object\n *\n * This file is coded in a pure functional style. That is, no function has \n * side effects, every function evaluates to the same value for the same \n * arguments and no variables are reassigned.\n */  \n// the call to jsonPathSyntax injects the token syntaxes that are needed \n// inside the compiler\nvar jsonPathCompiler = jsonPathSyntax(function (pathNodeSyntax, \n                                                doubleDotSyntax, \n                                                dotSyntax,\n                                                bangSyntax,\n                                                emptySyntax ) {\n\n   var CAPTURING_INDEX = 1;\n   var NAME_INDEX = 2;\n   var FIELD_LIST_INDEX = 3;\n\n   var headKey  = compose2(keyOf, head),\n       headNode = compose2(nodeOf, head);\n                   \n   /**\n    * Create an evaluator function for a named path node, expressed in the\n    * JSONPath like:\n    *    foo\n    *    [\"bar\"]\n    *    [2]   \n    */\n   function nameClause(previousExpr, detection ) {\n     \n      var name = detection[NAME_INDEX],\n            \n          matchesName = ( !name || name == '*' ) \n                           ?  always\n                           :  function(ascent){return headKey(ascent) == name};\n     \n\n      return lazyIntersection(matchesName, previousExpr);\n   }\n\n   /**\n    * Create an evaluator function for a a duck-typed node, expressed like:\n    * \n    *    {spin, taste, colour}\n    *    .particle{spin, taste, colour}\n    *    *{spin, taste, colour}\n    */\n   function duckTypeClause(previousExpr, detection) {\n\n      var fieldListStr = detection[FIELD_LIST_INDEX];\n\n      if (!fieldListStr) \n         return previousExpr; // don't wrap at all, return given expr as-is      \n\n      var hasAllrequiredFields = partialComplete(\n                                    hasAllProperties, \n                                    arrayAsList(fieldListStr.split(/\\W+/))\n                                 ),\n                                 \n          isMatch =  compose2( \n                        hasAllrequiredFields, \n                        headNode\n                     );\n\n      return lazyIntersection(isMatch, previousExpr);\n   }\n\n   /**\n    * Expression for $, returns the evaluator function\n    */\n   function capture( previousExpr, detection ) {\n\n      // extract meaning from the detection      \n      var capturing = !!detection[CAPTURING_INDEX];\n\n      if (!capturing)          \n         return previousExpr; // don't wrap at all, return given expr as-is      \n      \n      return lazyIntersection(previousExpr, head);\n            \n   }            \n      \n   /**\n    * Create an evaluator function that moves onto the next item on the \n    * lists. This function is the place where the logic to move up a \n    * level in the ascent exists. \n    * \n    * Eg, for JSONPath \".foo\" we need skip1(nameClause(always, [,'foo']))\n    */\n   function skip1(previousExpr) {\n   \n   \n      if( previousExpr == always ) {\n         /* If there is no previous expression this consume command \n            is at the start of the jsonPath.\n            Since JSONPath specifies what we'd like to find but not \n            necessarily everything leading down to it, when running\n            out of JSONPath to check against we default to true */\n         return always;\n      }\n\n      /** return true if the ascent we have contains only the JSON root,\n       *  false otherwise\n       */\n      function notAtRoot(ascent){\n         return headKey(ascent) != ROOT_PATH;\n      }\n      \n      return lazyIntersection(\n               /* If we're already at the root but there are more \n                  expressions to satisfy, can't consume any more. No match.\n\n                  This check is why none of the other exprs have to be able \n                  to handle empty lists; skip1 is the only evaluator that \n                  moves onto the next token and it refuses to do so once it \n                  reaches the last item in the list. */\n               notAtRoot,\n               \n               /* We are not at the root of the ascent yet.\n                  Move to the next level of the ascent by handing only \n                  the tail to the previous expression */ \n               compose2(previousExpr, tail) \n      );\n                                                                                                               \n   }   \n   \n   /**\n    * Create an evaluator function for the .. (double dot) token. Consumes\n    * zero or more levels of the ascent, the fewest that are required to find\n    * a match when given to previousExpr.\n    */   \n   function skipMany(previousExpr) {\n\n      if( previousExpr == always ) {\n         /* If there is no previous expression this consume command \n            is at the start of the jsonPath.\n            Since JSONPath specifies what we'd like to find but not \n            necessarily everything leading down to it, when running\n            out of JSONPath to check against we default to true */            \n         return always;\n      }\n          \n      var \n          // In JSONPath .. is equivalent to !.. so if .. reaches the root\n          // the match has succeeded. Ie, we might write ..foo or !..foo\n          // and both should match identically.\n          terminalCaseWhenArrivingAtRoot = rootExpr(),\n          terminalCaseWhenPreviousExpressionIsSatisfied = previousExpr,\n          recursiveCase = skip1(function(ascent) {\n             return cases(ascent);\n          }),\n\n          cases = lazyUnion(\n                     terminalCaseWhenArrivingAtRoot\n                  ,  terminalCaseWhenPreviousExpressionIsSatisfied\n                  ,  recursiveCase  \n                  );\n      \n      return cases;\n   }      \n   \n   /**\n    * Generate an evaluator for ! - matches only the root element of the json\n    * and ignores any previous expressions since nothing may precede !. \n    */   \n   function rootExpr() {\n      \n      return function(ascent){\n         return headKey(ascent) == ROOT_PATH;\n      };\n   }   \n         \n   /**\n    * Generate a statement wrapper to sit around the outermost \n    * clause evaluator.\n    * \n    * Handles the case where the capturing is implicit because the JSONPath\n    * did not contain a '$' by returning the last node.\n    */   \n   function statementExpr(lastClause) {\n      \n      return function(ascent) {\n   \n         // kick off the evaluation by passing through to the last clause\n         var exprMatch = lastClause(ascent);\n                                                     \n         return exprMatch === true ? head(ascent) : exprMatch;\n      };\n   }      \n                          \n   /**\n    * For when a token has been found in the JSONPath input.\n    * Compiles the parser for that token and returns in combination with the\n    * parser already generated.\n    * \n    * @param {Function} exprs  a list of the clause evaluator generators for\n    *                          the token that was found\n    * @param {Function} parserGeneratedSoFar the parser already found\n    * @param {Array} detection the match given by the regex engine when \n    *                          the feature was found\n    */\n   function expressionsReader( exprs, parserGeneratedSoFar, detection ) {\n                     \n      // if exprs is zero-length foldR will pass back the \n      // parserGeneratedSoFar as-is so we don't need to treat \n      // this as a special case\n      \n      return   foldR( \n                  function( parserGeneratedSoFar, expr ){\n         \n                     return expr(parserGeneratedSoFar, detection);\n                  }, \n                  parserGeneratedSoFar, \n                  exprs\n               );                     \n\n   }\n\n   /** \n    *  If jsonPath matches the given detector function, creates a function which\n    *  evaluates against every clause in the clauseEvaluatorGenerators. The\n    *  created function is propagated to the onSuccess function, along with\n    *  the remaining unparsed JSONPath substring.\n    *  \n    *  The intended use is to create a clauseMatcher by filling in\n    *  the first two arguments, thus providing a function that knows\n    *  some syntax to match and what kind of generator to create if it\n    *  finds it. The parameter list once completed is:\n    *  \n    *    (jsonPath, parserGeneratedSoFar, onSuccess)\n    *  \n    *  onSuccess may be compileJsonPathToFunction, to recursively continue \n    *  parsing after finding a match or returnFoundParser to stop here.\n    */\n   function generateClauseReaderIfTokenFound (\n     \n                        tokenDetector, clauseEvaluatorGenerators,\n                         \n                        jsonPath, parserGeneratedSoFar, onSuccess) {\n                        \n      var detected = tokenDetector(jsonPath);\n\n      if(detected) {\n         var compiledParser = expressionsReader(\n                                 clauseEvaluatorGenerators, \n                                 parserGeneratedSoFar, \n                                 detected\n                              ),\n         \n             remainingUnparsedJsonPath = jsonPath.substr(len(detected[0]));                \n                               \n         return onSuccess(remainingUnparsedJsonPath, compiledParser);\n      }         \n   }\n                 \n   /**\n    * Partially completes generateClauseReaderIfTokenFound above. \n    */\n   function clauseMatcher(tokenDetector, exprs) {\n        \n      return   partialComplete( \n                  generateClauseReaderIfTokenFound, \n                  tokenDetector, \n                  exprs \n               );\n   }\n\n   /**\n    * clauseForJsonPath is a function which attempts to match against \n    * several clause matchers in order until one matches. If non match the\n    * jsonPath expression is invalid and an error is thrown.\n    * \n    * The parameter list is the same as a single clauseMatcher:\n    * \n    *    (jsonPath, parserGeneratedSoFar, onSuccess)\n    */     \n   var clauseForJsonPath = lazyUnion(\n\n      clauseMatcher(pathNodeSyntax   , list( capture, \n                                             duckTypeClause, \n                                             nameClause, \n                                             skip1 ))\n                                                     \n   ,  clauseMatcher(doubleDotSyntax  , list( skipMany))\n       \n       // dot is a separator only (like whitespace in other languages) but \n       // rather than make it a special case, use an empty list of \n       // expressions when this token is found\n   ,  clauseMatcher(dotSyntax        , list() )  \n                                                                                      \n   ,  clauseMatcher(bangSyntax       , list( capture,\n                                             rootExpr))\n                                                          \n   ,  clauseMatcher(emptySyntax      , list( statementExpr))\n   \n   ,  function (jsonPath) {\n         throw Error('\"' + jsonPath + '\" could not be tokenised')      \n      }\n   );\n\n\n   /**\n    * One of two possible values for the onSuccess argument of \n    * generateClauseReaderIfTokenFound.\n    * \n    * When this function is used, generateClauseReaderIfTokenFound simply \n    * returns the compiledParser that it made, regardless of if there is \n    * any remaining jsonPath to be compiled.\n    */\n   function returnFoundParser(_remainingJsonPath, compiledParser){ \n      return compiledParser \n   }     \n              \n   /**\n    * Recursively compile a JSONPath expression.\n    * \n    * This function serves as one of two possible values for the onSuccess \n    * argument of generateClauseReaderIfTokenFound, meaning continue to\n    * recursively compile. Otherwise, returnFoundParser is given and\n    * compilation terminates.\n    */\n   function compileJsonPathToFunction( uncompiledJsonPath, \n                                       parserGeneratedSoFar ) {\n\n      /**\n       * On finding a match, if there is remaining text to be compiled\n       * we want to either continue parsing using a recursive call to \n       * compileJsonPathToFunction. Otherwise, we want to stop and return \n       * the parser that we have found so far.\n       */\n      var onFind =      uncompiledJsonPath\n                     ?  compileJsonPathToFunction \n                     :  returnFoundParser;\n                   \n      return   clauseForJsonPath( \n                  uncompiledJsonPath, \n                  parserGeneratedSoFar, \n                  onFind\n               );                              \n   }\n\n   /**\n    * This is the function that we expose to the rest of the library.\n    */\n   return function(jsonPath){\n        \n      try {\n         // Kick off the recursive parsing of the jsonPath \n         return compileJsonPathToFunction(jsonPath, always);\n         \n      } catch( e ) {\n         throw Error( 'Could not compile \"' + jsonPath + \n                      '\" because ' + e.message\n         );\n      }\n   }\n\n});\n\n/** \n * A pub/sub which is responsible for a single event type. A \n * multi-event type event bus is created by pubSub by collecting\n * several of these.\n * \n * @param {String} eventType                   \n *    the name of the events managed by this singleEventPubSub\n * @param {singleEventPubSub} [newListener]    \n *    place to notify of new listeners\n * @param {singleEventPubSub} [removeListener] \n *    place to notify of when listeners are removed\n */\nfunction singleEventPubSub(eventType, newListener, removeListener){\n\n   /** we are optimised for emitting events over firing them.\n    *  As well as the tuple list which stores event ids and\n    *  listeners there is a list with just the listeners which \n    *  can be iterated more quickly when we are emitting\n    */\n   var listenerTupleList,\n       listenerList;\n\n   function hasId(id){\n      return function(tuple) {\n         return tuple.id == id;      \n      };  \n   }\n              \n   return {\n\n      /**\n       * @param {Function} listener\n       * @param {*} listenerId \n       *    an id that this listener can later by removed by. \n       *    Can be of any type, to be compared to other ids using ==\n       */\n      on:function( listener, listenerId ) {\n         \n         var tuple = {\n            listener: listener\n         ,  id:       listenerId || listener // when no id is given use the\n                                             // listener function as the id\n         };\n\n         if( newListener ) {\n            newListener.emit(eventType, listener, tuple.id);\n         }\n         \n         listenerTupleList = cons( tuple,    listenerTupleList );\n         listenerList      = cons( listener, listenerList      );\n\n         return this; // chaining\n      },\n     \n      emit:function () {                                                                                           \n         applyEach( listenerList, arguments );\n      },\n      \n      un: function( listenerId ) {\n             \n         var removed;             \n              \n         listenerTupleList = without(\n            listenerTupleList,\n            hasId(listenerId),\n            function(tuple){\n               removed = tuple;\n            }\n         );    \n         \n         if( removed ) {\n            listenerList = without( listenerList, function(listener){\n               return listener == removed.listener;\n            });\n         \n            if( removeListener ) {\n               removeListener.emit(eventType, removed.listener, removed.id);\n            }\n         }\n      },\n      \n      listeners: function(){\n         // differs from Node EventEmitter: returns list, not array\n         return listenerList;\n      },\n      \n      hasListener: function(listenerId){\n         var test = listenerId? hasId(listenerId) : always;\n      \n         return defined(first( test, listenerTupleList));\n      }\n   };\n}\n/**\n * pubSub is a curried interface for listening to and emitting\n * events.\n * \n * If we get a bus:\n *    \n *    var bus = pubSub();\n * \n * We can listen to event 'foo' like:\n * \n *    bus('foo').on(myCallback)\n *    \n * And emit event foo like:\n * \n *    bus('foo').emit()\n *    \n * or, with a parameter:\n * \n *    bus('foo').emit('bar')\n *     \n * All functions can be cached and don't need to be \n * bound. Ie:\n * \n *    var fooEmitter = bus('foo').emit\n *    fooEmitter('bar');  // emit an event\n *    fooEmitter('baz');  // emit another\n *    \n * There's also an uncurried[1] shortcut for .emit and .on:\n * \n *    bus.on('foo', callback)\n *    bus.emit('foo', 'bar')\n * \n * [1]: http://zvon.org/other/haskell/Outputprelude/uncurry_f.html\n */\nfunction pubSub(){\n\n   var singles = {},\n       newListener = newSingle('newListener'),\n       removeListener = newSingle('removeListener'); \n      \n   function newSingle(eventName) {\n      return singles[eventName] = singleEventPubSub(\n         eventName, \n         newListener, \n         removeListener\n      );   \n   }      \n\n   /** pubSub instances are functions */\n   function pubSubInstance( eventName ){   \n      \n      return singles[eventName] || newSingle( eventName );   \n   }\n\n   // add convenience EventEmitter-style uncurried form of 'emit' and 'on'\n   ['emit', 'on', 'un'].forEach(function(methodName){\n   \n      pubSubInstance[methodName] = varArgs(function(eventName, parameters){\n         apply( parameters, pubSubInstance( eventName )[methodName]);\n      });   \n   });\n         \n   return pubSubInstance;\n}\n\n/**\n * This file declares some constants to use as names for event types.\n */\n\nvar // the events which are never exported are kept as \n    // the smallest possible representation, in numbers:\n    _S = 1,\n\n    // fired whenever a new node starts in the JSON stream:\n    NODE_OPENED     = _S++,\n\n    // fired whenever a node closes in the JSON stream:\n    NODE_CLOSED     = _S++,\n\n    // called if a .node callback returns a value - \n    NODE_SWAP       = _S++,\n    NODE_DROP       = _S++,\n\n    FAIL_EVENT      = 'fail',\n   \n    ROOT_NODE_FOUND = _S++,\n    ROOT_PATH_FOUND = _S++,\n   \n    HTTP_START      = 'start',\n    STREAM_DATA     = 'data',\n    STREAM_END      = 'end',\n    ABORTING        = _S++,\n\n    // SAX events butchered from Clarinet\n    SAX_KEY          = _S++,\n    SAX_VALUE_OPEN   = _S++,\n    SAX_VALUE_CLOSE  = _S++;\n    \nfunction errorReport(statusCode, body, error) {\n   try{\n      var jsonBody = JSON.parse(body);\n   }catch(e){}\n\n   return {\n      statusCode:statusCode,\n      body:body,\n      jsonBody:jsonBody,\n      thrown:error\n   };\n}    \n\n/** \n *  The pattern adaptor listens for newListener and removeListener\n *  events. When patterns are added or removed it compiles the JSONPath\n *  and wires them up.\n *  \n *  When nodes and paths are found it emits the fully-qualified match \n *  events with parameters ready to ship to the outside world\n */\n\nfunction patternAdapter(oboeBus, jsonPathCompiler) {\n\n   var predicateEventMap = {\n      node:oboeBus(NODE_CLOSED)\n   ,  path:oboeBus(NODE_OPENED)\n   };\n     \n   function emitMatchingNode(emitMatch, node, ascent) {\n         \n      /* \n         We're now calling to the outside world where Lisp-style \n         lists will not be familiar. Convert to standard arrays. \n   \n         Also, reverse the order because it is more common to \n         list paths \"root to leaf\" than \"leaf to root\"  */\n      var descent     = reverseList(ascent);\n                \n      emitMatch(\n         node,\n         \n         // To make a path, strip off the last item which is the special\n         // ROOT_PATH token for the 'path' to the root node          \n         listAsArray(tail(map(keyOf,descent))),  // path\n         listAsArray(map(nodeOf, descent))       // ancestors    \n      );         \n   }\n\n   /* \n    * Set up the catching of events such as NODE_CLOSED and NODE_OPENED and, if \n    * matching the specified pattern, propagate to pattern-match events such as \n    * oboeBus('node:!')\n    * \n    * \n    * \n    * @param {Function} predicateEvent \n    *          either oboeBus(NODE_CLOSED) or oboeBus(NODE_OPENED).\n    * @param {Function} compiledJsonPath          \n    */\n   function addUnderlyingListener( fullEventName, predicateEvent, compiledJsonPath ){\n   \n      var emitMatch = oboeBus(fullEventName).emit;\n   \n      predicateEvent.on( function (ascent) {\n\n         var maybeMatchingMapping = compiledJsonPath(ascent);\n\n         /* Possible values for maybeMatchingMapping are now:\n\n          false: \n          we did not match \n\n          an object/array/string/number/null: \n          we matched and have the node that matched.\n          Because nulls are valid json values this can be null.\n\n          undefined:\n          we matched but don't have the matching node yet.\n          ie, we know there is an upcoming node that matches but we \n          can't say anything else about it. \n          */\n         if (maybeMatchingMapping !== false) {\n\n            emitMatchingNode(\n               emitMatch, \n               nodeOf(maybeMatchingMapping), \n               ascent\n            );\n         }\n      }, fullEventName);\n     \n      oboeBus('removeListener').on( function(removedEventName){\n\n         // if the fully qualified match event listener is later removed, clean up \n         // by removing the underlying listener if it was the last using that pattern:\n      \n         if( removedEventName == fullEventName ) {\n         \n            if( !oboeBus(removedEventName).listeners(  )) {\n               predicateEvent.un( fullEventName );\n            }\n         }\n      });   \n   }\n\n   oboeBus('newListener').on( function(fullEventName){\n\n      var match = /(node|path):(.*)/.exec(fullEventName);\n      \n      if( match ) {\n         var predicateEvent = predicateEventMap[match[1]];\n                    \n         if( !predicateEvent.hasListener( fullEventName) ) {  \n                  \n            addUnderlyingListener(\n               fullEventName,\n               predicateEvent, \n               jsonPathCompiler( match[2] )\n            );\n         }\n      }    \n   })\n\n}\n\n/** \n * The instance API is the thing that is returned when oboe() is called.\n * it allows:\n * \n *    - listeners for various events to be added and removed\n *    - the http response header/headers to be read\n */\nfunction instanceApi(oboeBus, contentSource){\n\n   var oboeApi,\n       fullyQualifiedNamePattern = /^(node|path):./,\n       rootNodeFinishedEvent = oboeBus(ROOT_NODE_FOUND),\n       emitNodeDrop = oboeBus(NODE_DROP).emit,\n       emitNodeSwap = oboeBus(NODE_SWAP).emit,\n\n       /**\n        * Add any kind of listener that the instance api exposes \n        */          \n       addListener = varArgs(function( eventId, parameters ){\n             \n            if( oboeApi[eventId] ) {\n       \n               // for events added as .on(event, callback), if there is a \n               // .event() equivalent with special behaviour , pass through\n               // to that: \n               apply(parameters, oboeApi[eventId]);                     \n            } else {\n       \n               // we have a standard Node.js EventEmitter 2-argument call.\n               // The first parameter is the listener.\n               var event = oboeBus(eventId),\n                   listener = parameters[0];\n       \n               if( fullyQualifiedNamePattern.test(eventId) ) {\n                \n                  // allow fully-qualified node/path listeners \n                  // to be added                                             \n                  addForgettableCallback(event, listener);                  \n               } else  {\n       \n                  // the event has no special handling, pass through \n                  // directly onto the event bus:          \n                  event.on( listener);\n               }\n            }\n                \n            return oboeApi; // chaining\n       }),\n \n       /**\n        * Remove any kind of listener that the instance api exposes \n        */ \n       removeListener = function( eventId, p2, p3 ){\n             \n            if( eventId == 'done' ) {\n            \n               rootNodeFinishedEvent.un(p2);\n               \n            } else if( eventId == 'node' || eventId == 'path' ) {\n      \n               // allow removal of node and path \n               oboeBus.un(eventId + ':' + p2, p3);          \n            } else {\n      \n               // we have a standard Node.js EventEmitter 2-argument call.\n               // The second parameter is the listener. This may be a call\n               // to remove a fully-qualified node/path listener but requires\n               // no special handling\n               var listener = p2;\n\n               oboeBus(eventId).un(listener);                  \n            }\n               \n            return oboeApi; // chaining      \n       };                               \n                        \n   /** \n    * Add a callback, wrapped in a try/catch so as to not break the\n    * execution of Oboe if an exception is thrown (fail events are \n    * fired instead)\n    * \n    * The callback is used as the listener id so that it can later be\n    * removed using .un(callback)\n    */\n   function addProtectedCallback(eventName, callback) {\n      oboeBus(eventName).on(protectedCallback(callback), callback);\n      return oboeApi; // chaining            \n   }\n\n   /**\n    * Add a callback where, if .forget() is called during the callback's\n    * execution, the callback will be de-registered\n    */\n   function addForgettableCallback(event, callback, listenerId) {\n      \n      // listenerId is optional and if not given, the original\n      // callback will be used\n      listenerId = listenerId || callback;\n      \n      var safeCallback = protectedCallback(callback);\n   \n      event.on( function() {\n      \n         var discard = false;\n             \n         oboeApi.forget = function(){\n            discard = true;\n         };           \n         \n         apply( arguments, safeCallback );         \n               \n         delete oboeApi.forget;\n         \n         if( discard ) {\n            event.un(listenerId);\n         }\n      }, listenerId);\n      \n      return oboeApi; // chaining         \n   }\n      \n   /** \n    *  wrap a callback so that if it throws, Oboe.js doesn't crash but instead\n    *  handles it like a normal error\n    */\n   function protectedCallback( callback ) {\n      return function() {\n         try{      \n            return callback.apply(oboeApi, arguments);   \n         }catch(e)  {\n         \n            // An error occured during the callback, publish it on the event bus \n            oboeBus(FAIL_EVENT).emit( errorReport(undefined, undefined, e));\n         }      \n      }   \n   }\n\n   /**\n    * Return the fully qualified event for when a pattern matches\n    * either a node or a path\n    * \n    * @param type {String} either 'node' or 'path'\n    */      \n   function fullyQualifiedPatternMatchEvent(type, pattern) {\n      return oboeBus(type + ':' + pattern);\n   }\n\n   function wrapCallbackToSwapNodeIfSomethingReturned( callback ) {\n      return function() {\n         var returnValueFromCallback = callback.apply(this, arguments);\n\n         if( defined(returnValueFromCallback) ) {\n            \n            if( returnValueFromCallback == oboe.drop ) {\n               emitNodeDrop();\n            } else {\n               emitNodeSwap(returnValueFromCallback);\n            }\n         }\n      }\n   }\n\n   function addSingleNodeOrPathListener(eventId, pattern, callback) {\n\n      var effectiveCallback;\n\n      if( eventId == 'node' ) {\n         effectiveCallback = wrapCallbackToSwapNodeIfSomethingReturned(callback);\n      } else {\n         effectiveCallback = callback;\n      }\n      \n      addForgettableCallback(\n         fullyQualifiedPatternMatchEvent(eventId, pattern),\n         effectiveCallback,\n         callback\n      );\n   }\n\n   /**\n    * Add several listeners at a time, from a map\n    */\n   function addMultipleNodeOrPathListeners(eventId, listenerMap) {\n   \n      for( var pattern in listenerMap ) {\n         addSingleNodeOrPathListener(eventId, pattern, listenerMap[pattern]);\n      }\n   }    \n         \n   /**\n    * implementation behind .onPath() and .onNode()\n    */       \n   function addNodeOrPathListenerApi( eventId, jsonPathOrListenerMap, callback ){\n         \n      if( isString(jsonPathOrListenerMap) ) {\n         addSingleNodeOrPathListener(eventId, jsonPathOrListenerMap, callback);\n\n      } else {\n         addMultipleNodeOrPathListeners(eventId, jsonPathOrListenerMap);\n      }\n      \n      return oboeApi; // chaining\n   }\n      \n   \n   // some interface methods are only filled in after we receive\n   // values and are noops before that:          \n   oboeBus(ROOT_PATH_FOUND).on( function(rootNode) {\n      oboeApi.root = functor(rootNode);   \n   });\n\n   /**\n    * When content starts make the headers readable through the\n    * instance API\n    */\n   oboeBus(HTTP_START).on( function(_statusCode, headers) {\n   \n      oboeApi.header =  function(name) {\n                           return name ? headers[name] \n                                       : headers\n                                       ;\n                        }\n   });\n                                                               \n   /**\n    * Construct and return the public API of the Oboe instance to be \n    * returned to the calling application\n    */       \n   return oboeApi = {\n      on             : addListener,\n      addListener    : addListener, \n      removeListener : removeListener,\n      emit           : oboeBus.emit,                \n                \n      node           : partialComplete(addNodeOrPathListenerApi, 'node'),\n      path           : partialComplete(addNodeOrPathListenerApi, 'path'),\n      \n      done           : partialComplete(addForgettableCallback, rootNodeFinishedEvent),            \n      start          : partialComplete(addProtectedCallback, HTTP_START ),\n      \n      // fail doesn't use protectedCallback because \n      // could lead to non-terminating loops\n      fail           : oboeBus(FAIL_EVENT).on,\n      \n      // public api calling abort fires the ABORTING event\n      abort          : oboeBus(ABORTING).emit,\n      \n      // initially return nothing for header and root\n      header         : noop,\n      root           : noop,\n      \n      source         : contentSource\n   };   \n}\n    \n\n/**\n * This file sits just behind the API which is used to attain a new\n * Oboe instance. It creates the new components that are required\n * and introduces them to each other.\n */\n\nfunction wire (httpMethodName, contentSource, body, headers, withCredentials){\n\n   var oboeBus = pubSub();\n   \n   // Wire the input stream in if we are given a content source.\n   // This will usually be the case. If not, the instance created\n   // will have to be passed content from an external source.\n  \n   if( contentSource ) {\n\n      streamingHttp( oboeBus,\n                     httpTransport(), \n                     httpMethodName,\n                     contentSource,\n                     body,\n                     headers,\n                     withCredentials\n      );\n   }\n\n   clarinet(oboeBus);\n\n   ascentManager(oboeBus, incrementalContentBuilder(oboeBus));\n      \n   patternAdapter(oboeBus, jsonPathCompiler);      \n      \n   return instanceApi(oboeBus, contentSource);\n}\n\nfunction applyDefaults( passthrough, url, httpMethodName, body, headers, withCredentials, cached ){\n\n   headers = headers ?\n      // Shallow-clone the headers array. This allows it to be\n      // modified without side effects to the caller. We don't\n      // want to change objects that the user passes in.\n      JSON.parse(JSON.stringify(headers))\n      : {};\n\n   if( body ) {\n      if( !isString(body) ) {\n\n         // If the body is not a string, stringify it. This allows objects to\n         // be given which will be sent as JSON.\n         body = JSON.stringify(body);\n\n         // Default Content-Type to JSON unless given otherwise.\n         headers['Content-Type'] = headers['Content-Type'] || 'application/json';\n      }\n   } else {\n      body = null;\n   }\n\n   // support cache busting like jQuery.ajax({cache:false})\n   function modifiedUrl(baseUrl, cached) {\n\n      if( cached === false ) {\n\n         if( baseUrl.indexOf('?') == -1 ) {\n            baseUrl += '?';\n         } else {\n            baseUrl += '&';\n         }\n\n         baseUrl += '_=' + new Date().getTime();\n      }\n      return baseUrl;\n   }\n\n   return passthrough( httpMethodName || 'GET', modifiedUrl(url, cached), body, headers, withCredentials || false );\n}\n\n// export public API\nfunction oboe(arg1) {\n\n   // We use duck-typing to detect if the parameter given is a stream, with the\n   // below list of parameters.\n   // Unpipe and unshift would normally be present on a stream but this breaks\n   // compatibility with Request streams.\n   // See https://github.com/jimhigson/oboe.js/issues/65\n   \n   var nodeStreamMethodNames = list('resume', 'pause', 'pipe'),\n       isStream = partialComplete(\n                     hasAllProperties\n                  ,  nodeStreamMethodNames\n                  );\n   \n   if( arg1 ) {\n      if (isStream(arg1) || isString(arg1)) {\n\n         //  simple version for GETs. Signature is:\n         //    oboe( url )\n         //  or, under node:\n         //    oboe( readableStream )\n         return applyDefaults(\n            wire,\n            arg1 // url\n         );\n\n      } else {\n\n         // method signature is:\n         //    oboe({method:m, url:u, body:b, headers:{...}})\n\n         return applyDefaults(\n            wire,\n            arg1.url,\n            arg1.method,\n            arg1.body,\n            arg1.headers,\n            arg1.withCredentials,\n            arg1.cached\n         );\n         \n      }\n   } else {\n      // wire up a no-AJAX, no-stream Oboe. Will have to have content \n      // fed in externally and using .emit.\n      return wire();\n   }\n}\n\n/* oboe.drop is a special value. If a node callback returns this value the\n   parsed node is deleted from the JSON\n */\noboe.drop = function() {\n   return oboe.drop;\n};\n\n\n   if ( typeof define === \"function\" && define.amd ) {\n      define( \"oboe\", [], function () { return oboe; } );\n   } else if (typeof exports === 'object') {\n      module.exports = oboe;\n   } else {\n      window.oboe = oboe;\n   }\n})((function(){\n   // Access to the window object throws an exception in HTML5 web workers so\n   // point it to \"self\" if it runs in a web worker\n      try {\n         return window;\n      } catch (e) {\n         return self;\n      }\n   }()), Object, Array, Error, JSON);\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/Blob.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport RNFetchBlob from '../index.js'\nimport fs from '../fs.js'\nimport getUUID from '../utils/uuid'\nimport Log from '../utils/log.js'\nimport EventTarget from './EventTarget'\n\nconst log = new Log('Blob')\nconst blobCacheDir = fs.dirs.DocumentDir + '/RNFetchBlob-blobs/'\n\nlog.disable()\n// log.level(3)\n\n/**\n * A RNFetchBlob style Blob polyfill class, this is a Blob which compatible to\n * Response object attain fron RNFetchBlob.fetch.\n */\nexport default class Blob extends EventTarget {\n\n  cacheName:string;\n  type:string;\n  size:number;\n  isRNFetchBlobPolyfill:boolean = true;\n  multipartBoundary:string = null;\n\n  _ref:string = null;\n  _blobCreated:boolean = false;\n  _onCreated:Array<any> = [];\n  _closed:boolean = false;\n\n  /**\n   * Static method that remove all files in Blob cache folder.\n   * @nonstandard\n   * @return {Promise}\n   */\n  static clearCache() {\n    return fs.unlink(blobCacheDir).then(() => fs.mkdir(blobCacheDir))\n  }\n\n  static build(data:any, cType:any):Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      new Blob(data, cType).onCreated(resolve)\n    })\n  }\n\n  get blobPath() {\n    return this._ref\n  }\n\n  static setLog(level:number) {\n    if(level === -1)\n      log.disable()\n    else\n      log.level(level)\n  }\n\n  /**\n   * RNFetchBlob Blob polyfill, create a Blob directly from file path, BASE64\n   * encoded data, and string. The conversion is done implicitly according to\n   * given `mime`. However, the blob creation is asynchronously, to register\n   * event `onCreated` is need to ensure the Blob is creadted.\n   * @param  {any} data Content of Blob object\n   * @param  {any} mime Content type settings of Blob object, `text/plain`\n   *                    by default\n   * @param  {boolean} defer When this argument set to `true`, blob constructor\n   *                         will not invoke blob created event automatically.\n   */\n  constructor(data:any, cType:any, defer:boolean) {\n    super()\n    cType = cType || {}\n    this.cacheName = getBlobName()\n    this.isRNFetchBlobPolyfill = true\n    this.isDerived = defer\n    this.type = cType.type || 'text/plain'\n    log.verbose('Blob constructor called', 'mime', this.type, 'type', typeof data, 'length', data?  data.length:0)\n    this._ref = blobCacheDir + this.cacheName\n    let p = null\n    if(!data)\n      data = ''\n    if(data.isRNFetchBlobPolyfill) {\n      log.verbose('create Blob cache file from Blob object')\n      let size = 0\n      this._ref = String(data.getRNFetchBlobRef())\n      let orgPath = this._ref\n\n      p = fs.exists(orgPath)\n            .then((exist) =>  {\n              if(exist)\n                return fs.writeFile(orgPath, data, 'uri')\n                         .then((size) => Promise.resolve(size))\n                         .catch((err) => {\n                           throw `RNFetchBlob Blob file creation error, ${err}`\n                         })\n              else\n                throw `could not create Blob from path ${orgPath}, file not exists`\n            })\n    }\n    // process FormData\n    else if(data instanceof FormData) {\n      log.verbose('create Blob cache file from FormData', data)\n      let boundary = `RNFetchBlob-${this.cacheName}-${Date.now()}`\n      this.multipartBoundary = boundary\n      let parts = data.getParts()\n      let formArray = []\n      if(!parts) {\n        p = fs.writeFile(this._ref, '', 'utf8')\n      }\n      else {\n        for(let i in parts) {\n          formArray.push('\\r\\n--'+boundary+'\\r\\n')\n          let part = parts[i]\n          for(let j in part.headers) {\n            formArray.push(j + ': ' +part.headers[j] + '\\r\\n')\n          }\n          formArray.push('\\r\\n')\n          if(part.isRNFetchBlobPolyfill)\n            formArray.push(part)\n          else\n            formArray.push(part.string)\n        }\n        log.verbose('FormData array', formArray)\n        formArray.push('\\r\\n--'+boundary+'--\\r\\n')\n        p = createMixedBlobData(this._ref, formArray)\n      }\n    }\n    // if the data is a string starts with `RNFetchBlob-file://`, append the\n    // Blob data from file path\n    else if(typeof data === 'string' && data.startsWith('RNFetchBlob-file://')) {\n      log.verbose('create Blob cache file from file path', data)\n      this._ref = String(data).replace('RNFetchBlob-file://', '')\n      let orgPath = this._ref\n      if(defer)\n        return\n      else {\n        p = fs.stat(orgPath)\n              .then((stat) =>  {\n                return Promise.resolve(stat.size)\n              })\n      }\n    }\n    // content from variable need create file\n    else if(typeof data === 'string') {\n      let encoding = 'utf8'\n      let mime = String(this.type)\n      // when content type contains application/octet* or *;base64, RNFetchBlob\n      // fs will treat it as BASE64 encoded string binary data\n      if(/(application\\/octet|\\;base64)/i.test(mime))\n        encoding = 'base64'\n      else\n        data = data.toString()\n      // create cache file\n      this.type = String(this.type).replace(/;base64/ig, '')\n      log.verbose('create Blob cache file from string', 'encode', encoding)\n      p = fs.writeFile(this._ref, data, encoding)\n            .then((size) => {\n              return Promise.resolve(size)\n            })\n\n    }\n    // TODO : ArrayBuffer support\n    // else if (data instanceof ArrayBuffer ) {\n    //\n    // }\n    // when input is an array of mixed data types, create a file cache\n    else if(Array.isArray(data)) {\n      log.verbose('create Blob cache file from mixed array', data)\n      p = createMixedBlobData(this._ref, data)\n    }\n    else {\n      data = data.toString()\n      p = fs.writeFile(this._ref, data, 'utf8')\n            .then((size) => Promise.resolve(size))\n    }\n    p && p.then((size) => {\n      this.size = size\n      this._invokeOnCreateEvent()\n    })\n    .catch((err) => {\n      log.error('RNFetchBlob could not create Blob : '+ this._ref, err)\n    })\n\n  }\n\n  /**\n   * Since Blob content will asynchronously write to a file during creation,\n   * use this method to register an event handler for Blob initialized event.\n   * @nonstandard\n   * @param  {(b:Blob) => void} An event handler invoked when Blob created\n   * @return {Blob} The Blob object instance itself\n   */\n  onCreated(fn:() => void):Blob {\n    log.verbose('#register blob onCreated', this._blobCreated)\n    if(!this._blobCreated)\n      this._onCreated.push(fn)\n    else {\n      fn(this)\n    }\n    return this\n  }\n\n  markAsDerived() {\n    this._isDerived = true\n  }\n\n  get isDerived() {\n    return this._isDerived || false\n  }\n\n  /**\n   * Get file reference of the Blob object.\n   * @nonstandard\n   * @return {string} Blob file reference which can be consumed by RNFetchBlob fs\n   */\n  getRNFetchBlobRef() {\n    return this._ref\n  }\n\n  /**\n   * Create a Blob object which is sliced from current object\n   * @param  {number} start    Start byte number\n   * @param  {number} end      End byte number\n   * @param  {string} contentType Optional, content type of new Blob object\n   * @return {Blob}\n   */\n  slice(start:?number, end:?number, contentType:?string=''):Blob {\n    if(this._closed)\n      throw 'Blob has been released.'\n    log.verbose('slice called', start, end, contentType)\n\n\n    let resPath = blobCacheDir + getBlobName()\n    let pass = false\n    log.debug('fs.slice new blob will at', resPath)\n    let result = new Blob(RNFetchBlob.wrap(resPath), { type : contentType }, true)\n    fs.exists(blobCacheDir)\n    .then((exist) => {\n      if(exist)\n        return Promise.resolve()\n      return fs.mkdir(blobCacheDir)\n    })\n    .then(() => fs.slice(this._ref, resPath, start, end))\n    .then((dest) => {\n      log.debug('fs.slice done', dest)\n      result._invokeOnCreateEvent()\n      pass = true\n    })\n    .catch((err) => {\n      console.warn('Blob.slice failed:', err)\n      pass = true\n    })\n    log.debug('slice returning new Blob')\n\n    return result\n  }\n\n  /**\n   * Read data of the Blob object, this is not standard method.\n   * @nonstandard\n   * @param  {string} encoding Read data with encoding\n   * @return {Promise}\n   */\n  readBlob(encoding:string):Promise<any> {\n    if(this._closed)\n      throw 'Blob has been released.'\n    return fs.readFile(this._ref, encoding || 'utf8')\n  }\n\n  /**\n   * Release the resource of the Blob object.\n   * @nonstandard\n   * @return {Promise}\n   */\n  close() {\n    if(this._closed)\n      return Promise.reject('Blob has been released.')\n    this._closed = true\n    return fs.unlink(this._ref).catch((err) => {\n      console.warn(err)\n    })\n  }\n\n  _invokeOnCreateEvent() {\n    log.verbose('invoke create event', this._onCreated)\n    this._blobCreated = true\n    let fns = this._onCreated\n    for(let i in fns) {\n      if(typeof fns[i] === 'function') {\n        fns[i](this)\n      }\n    }\n    delete this._onCreated\n  }\n\n}\n\n/**\n * Get a temp filename for Blob object\n * @return {string} Temporary filename\n */\nfunction getBlobName() {\n  return 'blob-' + getUUID()\n}\n\n/**\n * Create a file according to given array. The element in array can be a number,\n * Blob, String, Array.\n * @param  {string} ref File path reference\n * @param  {Array} dataArray An array contains different types of data.\n * @return {Promise}\n */\nfunction createMixedBlobData(ref, dataArray) {\n  // create an empty file for store blob data\n  let p = fs.writeFile(ref, '')\n  let args = []\n  let size = 0\n  for(let i in dataArray) {\n    let part = dataArray[i]\n    if(!part)\n      continue\n    if(part.isRNFetchBlobPolyfill) {\n      args.push([ref, part._ref, 'uri'])\n    }\n    else if(typeof part === 'string')\n      args.push([ref, part, 'utf8'])\n    // TODO : ArrayBuffer\n    // else if (part instanceof ArrayBuffer) {\n    //\n    // }\n    else if (Array.isArray(part))\n      args.push([ref, part, 'ascii'])\n  }\n  // start write blob data\n  for(let i in args) {\n    p = p.then(function(written){\n      let arg = this\n      if(written)\n        size += written\n      log.verbose('mixed blob write', args[i], written)\n      return fs.appendFile(...arg)\n    }.bind(args[i]))\n  }\n  return p.then(() => Promise.resolve(size))\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/Event.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nexport default class Event {\n\n  constructor() {\n\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/EventTarget.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport Log from '../utils/log.js'\n\nconst log = new Log('EventTarget')\n\nlog.disable()\n\nexport default class EventTarget {\n\n  listeners : any;\n\n  constructor() {\n    log.info('constructor called')\n    this.listeners = {}\n  }\n\n  /**\n   * Add an event listener to given event type\n   * @param {string} type Event type string\n   * @param {(Event) => void} cb   Event handler function\n   */\n  addEventListener(type:string, cb : () => void) {\n    log.info('add event listener', type, cb)\n    if(!(type in this.listeners)) {\n      this.listeners[type] = []\n    }\n    this.listeners[type].push(cb)\n  }\n\n  /**\n   * Remove an event listener\n   * @param  {string} type Type of the event listener\n   * @param  {()=>void} cb Event listener function.\n   * @return {[type]}             [description]\n   */\n  removeEventListener(type:string, cb:() => void) {\n    log.info('remove event listener', type, cb)\n    if(!(type in this.listeners))\n      return\n    let handlers = this.listeners[type]\n    for(let i in handlers) {\n      if(cb === handlers[i]) {\n        handlers.splice(i,1)\n        return this.removeEventListener(type, cb)\n      }\n    }\n  }\n\n  /**\n   * Dispatch an event\n   * @param {string} type Event type.\n   * @param {Event} event Event data payload.\n   */\n  dispatchEvent(type:string,event:Event) {\n    log.info('dispatch event', event)\n    if(!(type in this.listeners))\n      return\n    let handlers = this.listeners[type]\n    for(let i in handlers) {\n      handlers[i].call(this, event)\n    }\n\n  }\n\n  /**\n   * Remove all registered listeners from this object.\n   * @nonstandard\n   * @return {[type]} [description]\n   */\n  clearEventListeners() {\n    for(let i in this.listeners) {\n      delete this.listeners[i]\n    }\n  }\n\n}","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/Fetch.js":"import RNFetchBlob from '../index.js'\nimport Log from '../utils/log.js'\nimport fs from '../fs'\nimport unicode from '../utils/unicode'\nimport Blob from './Blob'\n\nconst log = new Log('FetchPolyfill')\n\nlog.disable()\n// log.level(3)\n\nexport default class Fetch {\n\n  constructor(config:RNFetchBlobConfig) {\n    Object.assign(this, new RNFetchBlobFetchPolyfill(config))\n  }\n\n}\n\nclass RNFetchBlobFetchPolyfill {\n\n  constructor(config:RNFetchBlobConfig) {\n    this.build = () => (url, options = {}) => {\n\n      let body = options.body\n      let promise = Promise.resolve()\n      let blobCache = null\n\n      options.headers = options.headers || {}\n      let ctype = options['Content-Type'] || options['content-type']\n      let ctypeH = options.headers['Content-Type'] || options.headers['content-type']\n      options.headers['Content-Type'] = ctype || ctypeH\n      options.headers['content-type'] = ctype || ctypeH\n      options.method = options.method || 'GET'\n      if(body) {\n        // When the request body is an instance of FormData, create a Blob cache\n        // to upload the body.\n        if(body instanceof FormData) {\n          log.verbose('convert FormData to blob body')\n          promise = Blob.build(body).then((b) => {\n            blobCache = b\n            options.headers['Content-Type'] = 'multipart/form-data;boundary=' + b.multipartBoundary\n            return Promise.resolve(RNFetchBlob.wrap(b._ref))\n          })\n        }\n        // When request body is a Blob, use file URI of the Blob as request body.\n        else if (body.isRNFetchBlobPolyfill)\n          promise = Promise.resolve(RNFetchBlob.wrap(body.blobPath))\n        else if (typeof body !== 'object' && options.headers['Content-Type'] !== 'application/json')\n          promise = Promise.resolve(JSON.stringify(body))\n        else if (typeof body !== 'string')\n          promise = Promise.resolve(body.toString())\n        // send it as-is, leave the native module decide how to send the body.\n        else\n          promise = Promise.resolve(body)\n      }\n      // task is a progress reportable and cancellable Promise, however,\n      // task.then is not, so we have to extend task.then with progress and\n      // cancel function\n      let task = promise\n          .then((body) => {\n            return RNFetchBlob.config(config)\n            .fetch(options.method, url, options.headers, body)\n          })\n\n      let statefulPromise = task.then((resp) => {\n        log.verbose('response', resp)\n        // release blob cache created when sending request\n        if(blobCache !== null && blobCache instanceof Blob)\n          blobCache.close()\n        return Promise.resolve(new RNFetchBlobFetchRepsonse(resp))\n      })\n\n      // extend task.then progress with report and cancelling functions\n      statefulPromise.cancel = task.cancel\n      statefulPromise.progress = task.progress\n      statefulPromise.uploadProgress = task.uploadProgress\n\n      return statefulPromise\n\n    }\n  }\n\n}\n\nclass RNFetchBlobFetchRepsonse {\n\n  constructor(resp:FetchBlobResponse) {\n    let info = resp.info()\n    this.headers = info.headers\n    this.ok = info.status >= 200 && info.status <= 299,\n    this.status = info.status\n    this.type = 'basic'\n    this.bodyUsed = false\n    this.resp = resp\n    this.rnfbRespInfo = info\n    this.rnfbResp = resp\n  }\n\n  rawResp() {\n    return Promise.resolve(this.rnfbResp)\n  }\n\n  arrayBuffer(){\n    log.verbose('to arrayBuffer', this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readArrayBuffer(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  text() {\n    log.verbose('to text', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readText(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  json() {\n    log.verbose('to json', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readJSON(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  blob() {\n    log.verbose('to blob', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readBlob(this.rnfbResp, this.rnfbRespInfo)\n  }\n}\n\n/**\n * Get response data as array.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<Array>}\n */\nfunction readArrayBuffer(resp, info):Promise<Array> {\n  switch (info.rnfbEncode) {\n    case 'path':\n      return resp.readFile('ascii')\n      break\n    default:\n      let buffer = []\n      let str = resp.text()\n      for (let i in str) {\n        buffer[i] = str.charCodeAt(i);\n      }\n      return Promise.resolve(buffer)\n      break\n  }\n}\n\n/**\n * Get response data as string.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<string>}\n */\nfunction readText(resp, info):Promise<string> {\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.text())\n      break\n    case 'path':\n      return resp.text()\n      break\n    default:\n      return Promise.resolve(resp.text())\n      break\n  }\n}\n\n\n/**\n * Get response data as RNFetchBlob Blob polyfill object.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<Blob>}\n */\nfunction readBlob(resp, info):Promise<Blob> {\n  log.verbose('readBlob', resp, info)\n  return resp.blob()\n}\n\n/**\n * Get response data as JSON object.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<object>}\n */\nfunction readJSON(resp, info):Promise<object> {\n  log.verbose('readJSON', resp, info)\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.json())\n    case 'path':\n      return resp.json()\n    default:\n      return Promise.resolve(resp.json())\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/File.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport fs from '../fs.js'\nimport Blob from './Blob.js'\n\nexport default class File extends Blob {\n\n  name : string = '';\n\n  static build(name:string, data:any, cType:string):Promise<File> {\n    return new Promise((resolve, reject) => {\n      new File(data, cType).onCreated((f) => {\n        f.name = name\n        resolve(f)\n      })\n    })\n  }\n\n  constructor(data:any , cType:string) {\n    super(data, cType)\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/FileReader.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport RNFetchBlob from '../index.js'\nimport ProgressEvent from './ProgressEvent.js'\nimport EventTarget from './EventTarget'\nimport Blob from './Blob'\nimport Log from '../utils/log.js'\nimport fs from '../fs'\n\nconst log = new Log('FileReader')\n\nlog.level(3)\n\nexport default class FileReader extends EventTarget {\n\n  static get EMPTY(){\n    return 0\n  }\n  static get LOADING(){\n    return 1\n  }\n  static get DONE(){\n    return 2\n  }\n\n  // properties\n  _readState:number = 0;\n  _result:any;\n  _error:any;\n\n  get isRNFBPolyFill(){ return true }\n\n  // event handlers\n  onloadstart:(e:Event) => void;\n  onprogress:(e:Event) => void;\n  onload:(e:Event) => void;\n  onabort:(e:Event) => void;\n  onerror:(e:Event) => void;\n  onloadend:(e:Event) => void;\n\n  constructor() {\n    super()\n    log.verbose('file reader const')\n    this._result = null\n  }\n\n  abort() {\n    log.verbose('abort', b, label)\n  }\n\n  readAsArrayBuffer(b:Blob) {\n    log.verbose('readAsArrayBuffer', b, label)\n  }\n\n  readAsBinaryString(b:Blob) {\n    log.verbose('readAsBinaryString', b, label)\n  }\n\n  readAsText(b:Blob, label:?string) {\n    log.verbose('readAsText', b, label)\n  }\n\n  readAsDataURL(b:Blob) {\n    log.verbose('readAsDataURL', b, label)\n  }\n\n  dispatchEvent(event, e) {\n    log.verbose('dispatch event', event, e)\n    super.dispatchEvent(event, e)\n    if(typeof this[`on${event}`] === 'function') {\n      this[`on${event}`](e)\n    }\n  }\n\n  // private methods\n\n  // getters and setters\n\n  get readState() {\n    return this._readyState\n  }\n\n  get result() {\n    return this._result\n  }\n\n\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/ProgressEvent.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport Event from './Event'\n\nexport default class ProgressEvent extends Event {\n\n  _lengthComputable : boolean = false;\n  _loaded : number = -1;\n  _total : numver = -1;\n\n  constructor(lengthComputable, loaded, total) {\n    super()\n    this._lengthComputable = lengthComputable;\n    this._loaded = loaded\n    this._total = total\n  }\n\n  get lengthComputable() {\n    return this._lengthComputable\n  }\n\n  get loaded() {\n    return this._loaded\n  }\n\n  get total() {\n    return this._total\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/XMLHttpRequestEventTarget.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport EventTarget from './EventTarget.js'\nimport Log from '../utils/log.js'\n\nconst log = new Log('XMLHttpRequestEventTarget')\n\nlog.disable()\n// log.level(3)\n\nexport default class XMLHttpRequestEventTarget extends EventTarget {\n\n  _onabort : (e:Event) => void = () => {};\n  _onerror : (e:Event) => void = () => {};\n  _onload : (e:Event) => void = () => {};\n  _onloadstart : (e:Event) => void = () => {};\n  _onprogress : (e:Event) => void = () => {};\n  _ontimeout : (e:Event) => void = () => {};\n  _onloadend : (e:Event) => void = () => {};\n\n  constructor() {\n    super()\n    log.info('constructor called')\n  }\n\n  dispatchEvent(event:string, e:Event) {\n    log.debug('dispatch event', event, e)\n    super.dispatchEvent(event, e)\n    switch(event) {\n      case 'abort' :\n        this._onabort(e)\n      break;\n      case 'error' :\n        this._onerror(e)\n      break;\n      case 'load' :\n        this._onload(e)\n      break;\n      case 'loadstart' :\n        this._onloadstart(e)\n      break;\n      case 'loadend' :\n        this._onloadend(e)\n      break;\n      case 'progress' :\n        this._onprogress(e)\n      break;\n      case 'timeout' :\n        this._ontimeout(e)\n      break;\n    }\n  }\n\n  set onabort(fn:(e:Event) => void) {\n    log.info('set onabort')\n    this._onabort = fn\n  }\n\n  get onabort() {\n    return this._onabort\n  }\n  set onerror(fn:(e:Event) => void) {\n    log.info('set onerror')\n    this._onerror = fn\n  }\n\n  get onerror() {\n    return this._onerror\n  }\n\n  set onload(fn:(e:Event) => void) {\n    log.info('set onload', fn)\n    this._onload = fn\n  }\n\n  get onload() {\n    return this._onload\n  }\n\n  set onloadstart(fn:(e:Event) => void) {\n    log.info('set onloadstart')\n    this._onloadstart = fn\n  }\n\n  get onloadstart() {\n    return this._onloadstart\n  }\n\n  set onprogress(fn:(e:Event) => void) {\n    log.info('set onprogress')\n    this._onprogress = fn\n  }\n\n  get onprogress() {\n    return this._onprogress\n  }\n\n  set ontimeout(fn:(e:Event) => void) {\n    log.info('set ontimeout')\n    this._ontimeout = fn\n  }\n\n  get ontimeout() {\n    return this._ontimeout\n  }\n\n  set onloadend(fn:(e:Event) => void) {\n    log.info('set onloadend')\n    this._onloadend = fn\n  }\n\n  get onloadend() {\n    return this._onloadend\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/polyfill/XMLHttpRequest.js":"// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport RNFetchBlob from '../index.js'\nimport XMLHttpRequestEventTarget from './XMLHttpRequestEventTarget.js'\nimport Log from '../utils/log.js'\nimport Blob from './Blob.js'\nimport ProgressEvent from './ProgressEvent.js'\nimport URIUtil from '../utils/uri'\n\nconst log = new Log('XMLHttpRequest')\n\nlog.disable()\n// log.level(3)\n\nconst UNSENT = 0\nconst OPENED = 1\nconst HEADERS_RECEIVED = 2\nconst LOADING = 3\nconst DONE = 4\n\nexport default class XMLHttpRequest extends XMLHttpRequestEventTarget{\n\n  _onreadystatechange : () => void;\n\n  upload : XMLHttpRequestEventTarget = new XMLHttpRequestEventTarget();\n  static binaryContentTypes : Array<string> = [\n    'image/', 'video/', 'audio/'\n  ];\n\n  // readonly\n  _readyState : number = UNSENT;\n  _uriType : 'net' | 'file' = 'net';\n  _response : any = '';\n  _responseText : any = '';\n  _responseHeaders : any = {};\n  _responseType : '' | 'arraybuffer' | 'blob'  | 'json' | 'text' = '';\n  // TODO : not suppoted ATM\n  _responseURL : null = '';\n  _responseXML : null = '';\n  _status : number = 0;\n  _statusText : string = '';\n  _timeout : number = 60000;\n  _sendFlag : boolean = false;\n  _uploadStarted : boolean = false;\n  _increment : boolean = false;\n\n  // RNFetchBlob compatible data structure\n  _config : RNFetchBlobConfig = {};\n  _url : any;\n  _method : string;\n  _headers: any = {\n    'Content-Type' : 'text/plain'\n  };\n  _cleanUp : () => void = null;\n  _body: any;\n\n  // RNFetchBlob promise object, which has `progress`, `uploadProgress`, and\n  // `cancel` methods.\n  _task: any;\n\n  // constants\n  get UNSENT() { return UNSENT }\n  get OPENED() { return OPENED }\n  get HEADERS_RECEIVED() { return HEADERS_RECEIVED }\n  get LOADING() { return LOADING }\n  get DONE() { return DONE }\n\n  static get UNSENT() {\n    return UNSENT\n  }\n\n  static get OPENED() {\n    return OPENED\n  }\n\n  static get HEADERS_RECEIVED() {\n    return HEADERS_RECEIVED\n  }\n\n  static get LOADING() {\n    return LOADING\n  }\n\n  static get DONE() {\n    return DONE\n  }\n\n  static setLog(level:number) {\n    if(level === -1)\n      log.disable()\n    else\n      log.level(level)\n  }\n\n  static addBinaryContentType(substr:string) {\n    for(let i in XMLHttpRequest.binaryContentTypes) {\n      if(new RegExp(substr,'i').test(XMLHttpRequest.binaryContentTypes[i])) {\n        return\n      }\n    }\n    XMLHttpRequest.binaryContentTypes.push(substr)\n\n  }\n\n  static removeBinaryContentType(val) {\n    for(let i in XMLHttpRequest.binaryContentTypes) {\n      if(new RegExp(substr,'i').test(XMLHttpRequest.binaryContentTypes[i])) {\n        XMLHttpRequest.binaryContentTypes.splice(i,1)\n        return\n      }\n    }\n  }\n\n  constructor() {\n    log.verbose('XMLHttpRequest constructor called')\n    super()\n  }\n\n\n  /**\n   * XMLHttpRequest.open, always async, user and password not supported. When\n   * this method invoked, headers should becomes empty again.\n   * @param  {string} method Request method\n   * @param  {string} url Request URL\n   * @param  {true} async Always async\n   * @param  {any} user NOT SUPPORTED\n   * @param  {any} password NOT SUPPORTED\n   */\n  open(method:string, url:string, async:true, user:any, password:any) {\n    log.verbose('XMLHttpRequest open ', method, url, async, user, password)\n    this._method = method\n    this._url = url\n    this._headers = {}\n    this._increment = URIUtil.isJSONStreamURI(this._url)\n    this._url = this._url.replace(/^JSONStream\\:\\/\\//, '')\n    this._dispatchReadStateChange(XMLHttpRequest.OPENED)\n  }\n\n  /**\n   * Invoke this function to send HTTP request, and set body.\n   * @param  {any} body Body in RNfetchblob flavor\n   */\n  send(body) {\n\n    this._body = body\n\n    if(this._readyState !== XMLHttpRequest.OPENED)\n      throw 'InvalidStateError : XMLHttpRequest is not opened yet.'\n    let promise = Promise.resolve()\n    this._sendFlag = true\n    log.verbose('XMLHttpRequest send ', body)\n    let {_method, _url, _headers } = this\n    log.verbose('sending request with args', _method, _url, _headers, body)\n    log.verbose(typeof body, body instanceof FormData)\n\n    if(body instanceof Blob) {\n      log.debug('sending blob body', body._blobCreated)\n      promise = new Promise((resolve, reject) => {\n          body.onCreated((blob) => {\n            // when the blob is derived (not created by RN developer), the blob\n            // will be released after XMLHttpRequest sent\n            if(blob.isDerived) {\n              this._cleanUp = () => {\n                blob.close()\n              }\n            }\n            log.debug('body created send request')\n            body = RNFetchBlob.wrap(blob.getRNFetchBlobRef())\n            resolve()\n          })\n        })\n    }\n    else if(typeof body === 'object') {\n      body = JSON.stringify(body)\n      promise = Promise.resolve()\n    }\n    else {\n      body = body ? body.toString() : body\n      promise = Promise.resolve()\n    }\n\n    promise.then(() => {\n      log.debug('send request invoke', body)\n      for(let h in _headers) {\n        _headers[h] = _headers[h].toString()\n      }\n\n      this._task = RNFetchBlob\n                    .config({\n                      auto: true,\n                      timeout : this._timeout,\n                      increment : this._increment,\n                      binaryContentTypes : XMLHttpRequest.binaryContentTypes\n                    })\n                    .fetch(_method, _url, _headers, body)\n      this._task\n          .stateChange(this._headerReceived.bind(this))\n          .uploadProgress(this._uploadProgressEvent.bind(this))\n          .progress(this._progressEvent.bind(this))\n          .catch(this._onError.bind(this))\n          .then(this._onDone.bind(this))\n\n    })\n  }\n\n  overrideMimeType(mime:string) {\n    log.verbose('XMLHttpRequest overrideMimeType', mime)\n    this._headers['Content-Type'] = mime\n  }\n\n  setRequestHeader(name, value) {\n    log.verbose('XMLHttpRequest set header', name, value)\n    if(this._readyState !== OPENED || this._sendFlag) {\n      throw `InvalidStateError : Calling setRequestHeader in wrong state  ${this._readyState}`\n    }\n    // UNICODE SHOULD NOT PASS\n    if(typeof name !== 'string' || /[^\\u0000-\\u00ff]/.test(name)) {\n      throw 'TypeError : header field name should be a string'\n    }\n    //\n    let invalidPatterns = [\n      /[\\(\\)\\>\\<\\@\\,\\:\\\\\\/\\[\\]\\?\\=\\}\\{\\s\\ \\u007f\\;\\t\\0\\v\\r]/,\n      /tt/\n    ]\n    for(let i in invalidPatterns) {\n      if(invalidPatterns[i].test(name) || typeof name !== 'string') {\n        throw `SyntaxError : Invalid header field name ${name}`\n      }\n    }\n    this._headers[name] = value\n  }\n\n  abort() {\n    log.verbose('XMLHttpRequest abort ')\n    if(!this._task)\n      return\n    this._task.cancel((err) => {\n      let e = {\n        timeStamp : Date.now(),\n      }\n      if(this.onabort)\n        this.onabort()\n      if(err) {\n        e.detail = err\n        e.type = 'error'\n        this.dispatchEvent('error', e)\n      }\n      else {\n        e.type = 'abort'\n        this.dispatchEvent('abort', e)\n      }\n    })\n  }\n\n  getResponseHeader(field:string):string | null {\n    log.verbose('XMLHttpRequest get header', field, this._responseHeaders)\n    if(!this._responseHeaders)\n      return null\n    return (this._responseHeaders[field] || this._responseHeaders[field.toLowerCase()]) || null\n\n  }\n\n  getAllResponseHeaders():string | null {\n    log.verbose('XMLHttpRequest get all headers', this._responseHeaders)\n    if(!this._responseHeaders)\n      return ''\n    let result = ''\n    let respHeaders = this.responseHeaders\n    for(let i in respHeaders) {\n      result += `${i}: ${respHeaders[i]}${String.fromCharCode(0x0D,0x0A)}`\n    }\n    return result.substr(0, result.length-2)\n  }\n\n  _headerReceived(e) {\n    log.debug('header received ', this._task.taskId, e)\n    this.responseURL = this._url\n    if(e.state === \"2\") {\n      this._responseHeaders = e.headers\n      this._statusText = e.status\n      this._status = Math.floor(e.status)\n      this._dispatchReadStateChange(XMLHttpRequest.HEADERS_RECEIVED)\n    }\n  }\n\n  _uploadProgressEvent(send:number, total:number) {\n    if(!this._uploadStarted) {\n      this.upload.dispatchEvent('loadstart')\n      this._uploadStarted = true\n    }\n    if(send >= total)\n      this.upload.dispatchEvent('load')\n    this.upload.dispatchEvent('progress', new ProgressEvent(true, send, total))\n  }\n\n  _progressEvent(send:number, total:number, chunk:string) {\n    log.verbose(this.readyState)\n    if(this._readyState === XMLHttpRequest.HEADERS_RECEIVED)\n      this._dispatchReadStateChange(XMLHttpRequest.LOADING)\n    let lengthComputable = false\n    if(total && total >= 0)\n        lengthComputable = true\n    let e = new ProgressEvent(lengthComputable, send, total)\n\n    if(this._increment) {\n      this._responseText += chunk\n    }\n    this.dispatchEvent('progress', e)\n  }\n\n  _onError(err) {\n    let statusCode = Math.floor(this.status)\n    if(statusCode >= 100 && statusCode !== 408) {\n      return\n    }\n    log.debug('XMLHttpRequest error', err)\n    this._statusText = err\n    this._status = String(err).match(/\\d+/)\n    this._status = this._status ? Math.floor(this.status) : 404\n    this._dispatchReadStateChange(XMLHttpRequest.DONE)\n    if(err && String(err.message).match(/(timed\\sout|timedout)/) || this._status == 408) {\n      this.dispatchEvent('timeout')\n    }\n    this.dispatchEvent('loadend')\n    this.dispatchEvent('error', {\n      type : 'error',\n      detail : err\n    })\n    this.clearEventListeners()\n  }\n\n  _onDone(resp) {\n    log.debug('XMLHttpRequest done', this._url, resp, this)\n    this._statusText = this._status\n    let responseDataReady = () => {\n      log.debug('request done state = 4')\n      this.dispatchEvent('load')\n      this.dispatchEvent('loadend')\n      this._dispatchReadStateChange(XMLHttpRequest.DONE)\n      this.clearEventListeners()\n    }\n    if(resp) {\n      let info = resp.respInfo || {}\n      log.debug(this._url, info, info.respType)\n      switch(this._responseType) {\n        case 'blob' :\n          resp.blob().then((b) => {\n            this._responseText = resp.text()\n            this._response = b\n            responseDataReady()\n          })\n        break;\n        case 'arraybuffer':\n          // TODO : to array buffer\n        break\n        case 'json':\n          this._response = resp.json()\n          this._responseText = resp.text()\n        break\n        default :\n          this._responseText = resp.text()\n          this._response = this.responseText\n          responseDataReady()\n        break;\n      }\n    }\n\n  }\n\n  _dispatchReadStateChange(state) {\n    this._readyState = state\n    if(typeof this._onreadystatechange === 'function')\n      this._onreadystatechange()\n  }\n\n  set onreadystatechange(fn:() => void) {\n    log.verbose('XMLHttpRequest set onreadystatechange', fn)\n    this._onreadystatechange = fn\n  }\n\n  get onreadystatechange() {\n    return this._onreadystatechange\n  }\n\n  get readyState() {\n    log.verbose('get readyState', this._readyState)\n    return this._readyState\n  }\n\n  get status() {\n    log.verbose('get status', this._status)\n    return this._status\n  }\n\n  get statusText() {\n    log.verbose('get statusText', this._statusText)\n    return this._statusText\n  }\n\n  get response() {\n    log.verbose('get response', this._response)\n    return this._response\n  }\n\n  get responseText() {\n    log.verbose('get responseText', this._responseText)\n    return this._responseText\n  }\n\n  get responseURL() {\n    log.verbose('get responseURL', this._responseURL)\n    return this._responseURL\n  }\n\n  get responseHeaders() {\n    log.verbose('get responseHeaders', this._responseHeaders)\n    return this._responseHeaders\n  }\n\n  set timeout(val) {\n    this._timeout = val*1000\n    log.verbose('set timeout', this._timeout)\n  }\n\n  get timeout() {\n    log.verbose('get timeout', this._timeout)\n    return this._timeout\n  }\n\n  set responseType(val) {\n    log.verbose('set response type', this._responseType)\n    this._responseType = val\n  }\n\n  get responseType() {\n    log.verbose('get response type', this._responseType)\n    return this._responseType\n  }\n\n  static get isRNFBPolyfill() {\n    return true\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/scripts/prelink.js":"try {\n  var fs = require('fs');\n  var glob = require('glob');\n  var addAndroidPermissions = process.env.RNFB_ANDROID_PERMISSIONS == 'true';\n  var MANIFEST_PATH = glob.sync(process.cwd() + '/android/app/src/main/**/AndroidManifest.xml')[0];\n  var PACKAGE_JSON = process.cwd() + '/package.json';\n  var package = JSON.parse(fs.readFileSync(PACKAGE_JSON));\n  var APP_NAME = package.name;\n  var PACKAGE_GRADLE = process.cwd() + '/node_modules/react-native-fetch-blob/android/build.gradle'\n  var VERSION = checkVersion();\n\n  console.log('RNFetchBlob detected app version => ' + VERSION);\n\n  if(VERSION < 0.28) {\n    console.log('You project version is '+ VERSION + ' which may not compatible to react-native-fetch-blob 7.0+, please consider upgrade your application template to react-native 0.27+.')\n    // add OkHttp3 dependency fo pre 0.28 project\n    var main = fs.readFileSync(PACKAGE_GRADLE);\n    console.log('adding OkHttp3 dependency to pre 0.28 project .. ')\n    main = String(main).replace('//{RNFetchBlob_PRE_0.28_DEPDENDENCY}', \"compile 'com.squareup.okhttp3:okhttp:3.4.1'\");\n    fs.writeFileSync(PACKAGE_GRADLE, main);\n    console.log('adding OkHttp3 dependency to pre 0.28 project .. ok')\n  }\n\n  console.log('Add Android permissions => ' + (addAndroidPermissions == \"true\"))\n\n  if(addAndroidPermissions) {\n\n    // set file access permission for Android < 6.0\n    fs.readFile(MANIFEST_PATH, function(err, data) {\n\n      if(err)\n        console.log('failed to locate AndroidManifest.xml file, you may have to add file access permission manually.');\n      else {\n\n        console.log('RNFetchBlob patching AndroidManifest.xml .. ');\n        // append fs permission\n        data = String(data).replace(\n          '<uses-permission android:name=\"android.permission.INTERNET\" />',\n          '<uses-permission android:name=\"android.permission.INTERNET\" />\\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /> '\n        )\n        // append DOWNLOAD_COMPLETE intent permission\n        data = String(data).replace(\n          '<category android:name=\"android.intent.category.LAUNCHER\" />',\n          '<category android:name=\"android.intent.category.LAUNCHER\" />\\n     <action android:name=\"android.intent.action.DOWNLOAD_COMPLETE\"/>'\n        )\n        fs.writeFileSync(MANIFEST_PATH, data);\n        console.log('RNFetchBlob patching AndroidManifest.xml .. ok');\n\n      }\n\n    })\n  }\n  else {\n    console.log(\n      '\\033[95mreact-native-fetch-blob \\033[97mwill not automatically add Android permissions after \\033[92m0.9.4 '+\n      '\\033[97mplease run the following command if you want to add default permissions :\\n\\n' +\n      '\\033[96m\\tRNFB_ANDROID_PERMISSIONS=true react-native link \\n')\n  }\n\n  function checkVersion() {\n    console.log('RNFetchBlob checking app version ..');\n    return parseFloat(/\\d\\.\\d+(?=\\.)/.exec(package.dependencies['react-native']));\n  }\n\n} catch(err) {\n  console.log(\n    '\\033[95mreact-native-fetch-blob\\033[97m link \\033[91mFAILED \\033[97m\\nCould not automatically link package :'+\n    err.stack +\n    'please follow the instructions to manually link the library : ' +\n    '\\033[4mhttps://github.com/wkh237/react-native-fetch-blob/wiki/Manually-Link-Package\\n')\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/utils/unicode.js":"export default function(x) {\n  var r = /\\\\u([\\d\\w]{4})/gi\n  x = x.replace(r, function (match, grp) {\n    return String.fromCharCode(parseInt(grp, 16))\n  })\n  return unescape(x)\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/utils/uri.js":"export default {\n\n  isFileURI : (uri:string):boolean => {\n    if(typeof uri !== 'string')\n      return false\n    return /^RNFetchBlob-file\\:\\/\\//.test(uri)\n  },\n\n  isJSONStreamURI : (uri:string):boolean => {\n    if(typeof uri !== 'string')\n      return false\n    return /^JSONStream\\:\\/\\//.test(uri)\n  },\n\n  removeURIScheme : (uri:string, iterations:number):string => {\n    iterations = iterations || 1\n    let result = uri\n    for(let i=0;i<iterations;i++) {\n      result = String(result).replace(/^[^\\:]+\\:\\/\\//, '')\n    }\n    return String(result)\n  },\n\n  unwrapFileURI : (uri:string):string => {\n    return String(uri).replace(/^RNFetchBlob-file\\:\\/\\//, '')\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-fetch-blob/node_modules/react-native-fetch-blob/utils/uuid.js":"export default function getUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    let r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  });\n}\n"}